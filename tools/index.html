<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIGIT//MATCH - Market Signal Tool</title>
    <link rel="stylesheet" href="../css/tools.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- PWA Manifest Link -->
    <link rel="manifest" href="manifest.json">
    <!-- Theme Color for PWA -->
    <meta name="theme-color" content="#2c3e50">
    <style>
        /* Trading Button Styles */
        .trade-button {
            background-color: var(--success-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            margin-left: 20px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
        }
        
        .trade-button:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        /* Trading iFrame Container - MODIFIED for better responsive sizing */
        .trade-iframe-container {
            display: none;
            position: fixed;
            top: 90px; /* Position below header */
            right: 20px;
            width: 45%; /* Take less width */
            height: calc(100vh - 120px);
            background-color: #fff;
            z-index: 900; /* Lower z-index so it doesn't block alerts */
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            flex-direction: column; /* Stack header and iframe vertically */
            overflow: hidden;
            transform: translate(0, 0); /* Base transform for all screen sizes */
            transition: none; /* Remove transition to make dragging smooth */
            max-width: 95vw; /* Never exceed viewport width */
            max-height: 95vh; /* Never exceed viewport height */
        }
        
        /* Make dashboard adjust when trading platform is active */
        .dashboard.with-trading-platform {
            width: 53%;
            transition: width 0.3s ease;
        }
        
        .iframe-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--primary-bg);
            color: white;
            padding: 10px 15px;
            font-weight: bold;
            cursor: move; /* Always show move cursor */
        }
        
        /* Drag handle in header for all screen sizes */
        .drag-handle {
            display: inline-block;
            margin-right: 10px;
            font-size: 16px;
            cursor: move;
            color: rgba(255, 255, 255, 0.8);
        }
        
        /* Resizing handle for all screen sizes */
        .resize-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            bottom: 0;
            right: 0;
            cursor: nwse-resize;
            background: rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .resize-handle::before {
            content: "";
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 0 10px 10px;
            border-color: transparent transparent var(--primary-bg) transparent;
        }
        
        .trade-iframe-container.draggable {
            cursor: move;
        }
        
        /* Make sure iframe fits properly inside container - FIX HEIGHT ISSUES */
        #tradeIframe {
            width: 100%;
            height: calc(100% - 40px) !important; /* Force correct height calculation */
            border: none;
            display: block; /* Prevent inline display issues */
            min-height: 300px; /* Ensure minimum height on large screens */
            flex: 1; /* Allow iframe to fill available space */
        }
        
        /* Just make a few adjustments for mobile screens */
        @media screen and (max-width: 768px) {
            .trade-iframe-container {
                width: 90%; /* Wider on small screens */
                height: min(40vh, 400px); /* Limit height on small screens */
                max-height: 60vh;
                top: auto;
                bottom: 20px;
                left: 5%;
                min-width: 280px;
                min-height: 200px;
            }
            
            /* Ensure iframe contents scale properly */
            #tradeIframe {
                height: calc(100% - 40px);
                width: 100%;
            }
            
            .dashboard.with-trading-platform {
                width: 100%;
                margin-bottom: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Login/Register Modal -->
    <div id="loginOverlay" class="login-overlay">
        <div class="login-popup">
            <div class="auth-tabs">
                <button id="loginTabBtn" class="auth-tab"><i class="fas fa-sign-in-alt"></i> Login</button>
                <button id="registerTabBtn" class="auth-tab active"><i class="fas fa-user-plus"></i> Register</button>
            </div>
            
            <!-- Login Form -->
            <div id="loginFormContainer" class="auth-form-container">
                <h2><i class="fas fa-lock"></i> Secure Access</h2>
                <form id="loginForm">
                    <div class="input-group">
                        <label for="username"><i class="fas fa-user"></i> Username:</label>
                        <input type="text" id="username" name="username" required>
                    </div>
                    <div class="input-group">
                        <label for="password"><i class="fas fa-key"></i> Password:</label>
                        <div class="password-container">
                            <input type="password" id="password" name="password" required>
                            <button type="button" class="password-toggle" data-target="password">
                                <i class="fas fa-eye"></i>
                            </button>
                        </div>
                    </div>
                    <button type="submit" class="btn primary btn-login"><i class="fas fa-sign-in-alt"></i> Login</button>
                    <div id="loginError" class="login-error"></div>
                </form>
            </div>
            
            <!-- Register Form -->
            <div id="registerFormContainer" class="auth-form-container active">
                <h2><i class="fas fa-user-plus"></i> Create Account</h2>
                <form id="registerForm">
                    <div class="input-group">
                        <label for="regUsername"><i class="fas fa-user"></i> Username:</label>
                        <input type="text" id="regUsername" name="regUsername" required>
                    </div>
                    <div class="input-group">
                        <label for="regEmail"><i class="fas fa-user"></i> Email Username:</label>
                        <input type="text" id="regEmail" name="regEmail" required>
                    </div>
                    <div class="input-group">
                        <label for="regPassword"><i class="fas fa-key"></i> Password:</label>
                        <div class="password-container">
                            <input type="password" id="regPassword" name="regPassword" required>
                            <button type="button" class="password-toggle" data-target="regPassword">
                                <i class="fas fa-eye"></i>
                            </button>
                        </div>
                    </div>
                    <div class="input-group">
                        <label for="regConfirmPassword"><i class="fas fa-check-double"></i> Confirm Password:</label>
                        <div class="password-container">
                            <input type="password" id="regConfirmPassword" name="regConfirmPassword" required>
                            <button type="button" class="password-toggle" data-target="regConfirmPassword">
                                <i class="fas fa-eye"></i>
                            </button>
                        </div>
                    </div>
                    <button type="submit" class="btn primary btn-register"><i class="fas fa-user-plus"></i> Create Account</button>
                    <div id="registerError" class="login-error"></div>
                </form>
            </div>

            <div class="disclaimer-trigger-container">
                <a href="#" id="disclaimerLink" class="disclaimer-link">
                    <i class="fas fa-info-circle"></i> Important Disclaimer
                </a>
            </div>

        </div>
    </div>

    <!-- Disclaimer Modal -->
    <div id="disclaimerOverlay" class="disclaimer-overlay" style="display: none;">
        <div class="disclaimer-popup">
            <button id="closeDisclaimerPopup" class="close-btn disclaimer-close-btn">&times;</button>
            <h3><i class="fas fa-exclamation-triangle"></i> Important Disclaimer</h3>
            
            <div class="official-channels">
                <h4><i class="fas fa-id-badge"></i> Official Channels</h4>
                <p class="channels-intro">For support, updates, and official content, please only use these verified channels:</p>
                <ul class="social-links-list">
                    <li class="social-item">
                        <i class="fab fa-instagram"></i>
                        <span class="social-label">Instagram:</span>
                        <a href="https://www.instagram.com/derivlite.com_/" target="_blank" rel="noopener noreferrer">@derivlite.com_</a>
                    </li>
                    <li class="social-item">
                        <i class="fab fa-tiktok"></i>
                        <span class="social-label">TikTok:</span>
                        <a href="https://www.tiktok.com/@derivlite.com" target="_blank" rel="noopener noreferrer">@derivlite.com</a>
                    </li>
                    <li class="social-item">
                        <i class="fas fa-phone-alt"></i>
                        <span class="social-label">Support:</span>
                        <a href="tel:+254714653438">+254714653438</a>
                    </li>
                </ul>
                <p class="verification-note"><i class="fas fa-shield-alt"></i> Always verify you're using our official channels. We will never contact you from different accounts.</p>
            </div>
            
            <p><strong>Affiliation & API Usage:</strong> DIGIT//MATCH (derivlite.com) is an independent entity. We utilize the official Deriv API to provide market data and analysis. We are also an Introducing Broker (IB) for Deriv. However, we are not otherwise affiliated with, endorsed by, or in any way officially connected with Deriv Limited or its other brands (e.g., Binary.com™) beyond this stated API usage and IB relationship, nor any other brokers, companies, or individuals, except where explicitly stated.</p>
            <p><strong>Trademarks:</strong> Deriv™ and Binary.com™ are trademarks of Deriv Limited. Any other product names, logos, brands, and other trademarks or images featured or referred to within the DIGIT//MATCH website and/or on any social media forum are the property of their respective trademark holders. These trademark holders are not affiliated with DIGIT//MATCH, our products, or our websites, other than our disclosed use of the Deriv API and IB status. They do not sponsor or endorse our materials unless explicitly stated.</p>
            <p><strong>Risk Warning:</strong> This tool is provided for informational and educational purposes only. Trading financial markets, including derivatives, involves a substantial risk of loss and is not suitable for all investors. Past performance is not indicative of future results. Use this tool and any information provided at your own discretion and risk. We are not responsible for any financial losses incurred. Ensure you understand the risks involved before trading.</p>
            
            <p class="disclaimer-note">By using this tool, you acknowledge and agree to this disclaimer.</p>
        </div>
    </div>

    <!-- Payment Modal -->
    <div id="paymentOverlay" class="payment-overlay">
        <div class="payment-popup">
            <button id="closePaymentPopup" class="close-btn">&times;</button>
            <h3><i class="fab fa-bitcoin"></i> Payment Request</h3>
            <p>Derivlite has requested <strong>250 USDT</strong> payment. Tap the link below to complete the payment via Binance:</p>
            <a href="https://s.binance.com/R29up4mZ" target="_blank" class="payment-link">
                https://s.binance.com/R29up4mZ
            </a>
            <p>After payment, contact support to receive your login credentials.</p>
        </div>
    </div>

    <div class="container">
        <header class="main-header">
            <div class="logo">DIGIT<span class="accent">//</span>MATCH</div>
            <!-- Admin Panel Link Placeholder -->
            <a href="#" id="adminLink" class="admin-link"><i class="fas fa-user-shield"></i> Admin Panel</a>
            <!-- Trade Button -->
            <button id="tradeButton" class="trade-button"><i class="fas fa-exchange-alt"></i> Trade Here</button>
            <div class="status-indicator">
                <span class="status-dot"></span>
                <span class="status-text">SYSTEM ONLINE</span>
            </div>
        </header>

        <!-- Trading iframe container - initially hidden -->
        <div id="tradeIframeContainer" class="trade-iframe-container">
            <div class="iframe-header">
                <span>Trading Platform</span>
                <button id="closeIframe" class="close-iframe-btn"><i class="fas fa-times"></i></button>
            </div>
            <iframe id="tradeIframe" src="about:blank" frameborder="0"></iframe>
        </div>

        <div class="dashboard">
            <div class="panel control-panel">
                <h2><i class="fas fa-power-off"></i> System Control</h2>
                <div class="control-group">
                    <button id="startAnalysis" class="btn primary"><i class="fas fa-play"></i> START FEED</button>
                    <button id="stopAnalysis" class="btn danger" disabled><i class="fas fa-stop"></i> STOP FEED</button>
                </div>
                <div class="settings">
                    <div class="setting-group">
                        <label for="tickCount">Analysis Depth:</label>
                        <input type="number" id="tickCount" value="300" min="10" max="5000">
                    </div>
                    <!-- Add new setting for fetch count -->
                    <div class="setting-group">
                        <label for="fetchCount">Fetch Count:</label>
                        <input type="number" id="fetchCount" value="300" min="1" max="5000">
                    </div>
                    <!-- Add a checkbox to enable dynamic tick fetching -->
                    <div class="setting-group">
                        <label for="dynamicFetch">Dynamic Fetch:</label>
                        <input type="checkbox" id="dynamicFetch" checked>
                    </div>
                </div>
            </div>

            <div class="panel log-terminal">
                <h2><i class="fas fa-terminal"></i> Signal Log</h2>
                <div class="terminal" id="terminal">
                    <div class="log-line">[SYSTEM] Signal tool initialized...</div>
                    <div class="log-line">[INFO] Click "START FEED" to begin receiving signals...</div>
                </div>
            </div>

            <div class="panel prediction-panel">
                <h2><i class="fas fa-broadcast-tower"></i> Market Signal</h2>
                <div class="prediction-result">
                    <h3 id="signalMarket">Market: --</h3>
                    <div class="prediction-digits">
                        <span>Waiting for signal...</span>
                    </div>
                </div>
                <!-- Add signal countdown timer -->
                <div id="signalCountdown" class="signal-countdown" style="display: none;">
                    <span class="countdown-label">Signal valid for: </span>
                    <span class="countdown-value">35s</span>
                </div>
                <div class="recommendation">
                    <h3>Trade Recommendation:</h3>
                    <div class="trade-action">
                        <button class="btn action" disabled>N/A</button>
                        <button class="btn action" disabled>N/A</button>
                    </div>
                    <div class="confidence-meter">
                        <div class="confidence-label">Frequency: 0%</div>
                        <div class="meter-bar">
                            <div class="meter-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="../js/tools.js"></script>
    <script>
        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/tools/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }

        // Define matrixLogs in the global scope so it's available to all functions
        const matrixLogs = [
            "0x", "HASH:", "ADDR:", "MEM:", "BUFF:", "KEY:", "SEED:"
        ];

        // Move these variables to global scope so they're accessible to all functions
        let analysisRunning = false;
        let logInterval;
        let fastLogInterval;
        let tickInterval;
        let predictionTimer = null;
        let marketStates = new Map(); // Stores { history: [], latestTickTime: 0, maxDecimals: 0 }
        let subscribedMarkets = new Set(); // Add subscription tracking
        let signalLockUntil = 0; // Timestamp when next signal can be shown
        let countdownInterval = null;
        let currentPredictionMarket = null; // Track which market has an active prediction
        let ws = null;

        // Declare DOM references in global scope
        let terminal;
        let startBtn;
        let stopBtn;
        let signalMarketEl;
        let tickCountInput;
        let fetchCountInput;
        let dynamicFetchCheckbox;
        let marketAnalyzers;
        let adminLink;

        document.addEventListener('DOMContentLoaded', function() {
            // Auth UI Elements
            const loginOverlay = document.getElementById('loginOverlay');
            const loginTabBtn = document.getElementById('loginTabBtn');
            const registerTabBtn = document.getElementById('registerTabBtn');
            const loginFormContainer = document.getElementById('loginFormContainer');
            const registerFormContainer = document.getElementById('registerFormContainer');
            const loginForm = document.getElementById('loginForm');
            const registerForm = document.getElementById('registerForm');
            const loginError = document.getElementById('loginError');
            const registerError = document.getElementById('registerError');

            // Disclaimer Modal Elements
            const disclaimerLink = document.getElementById('disclaimerLink');
            const disclaimerOverlay = document.getElementById('disclaimerOverlay');
            const closeDisclaimerPopup = document.getElementById('closeDisclaimerPopup');
            
            // Payment Modal Elements
            const paymentOverlay = document.getElementById('paymentOverlay');
            const closePaymentPopup = document.getElementById('closePaymentPopup');
            
            // Tool Elements
            adminLink = document.getElementById('adminLink');
            terminal = document.getElementById('terminal');
            startBtn = document.getElementById('startAnalysis');
            stopBtn = document.getElementById('stopAnalysis');
            signalMarketEl = document.getElementById('signalMarket');
            tickCountInput = document.getElementById('tickCount');
            fetchCountInput = document.getElementById('fetchCount');
            dynamicFetchCheckbox = document.getElementById('dynamicFetch');

            // Add stylesheet for auth elements
            const authStyles = document.createElement('link');
            authStyles.rel = 'stylesheet';
            authStyles.href = '../css/auth.css';
            document.head.appendChild(authStyles);

            // Disclaimer Popup Logic
            if (disclaimerLink && disclaimerOverlay && closeDisclaimerPopup) {
                disclaimerLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    disclaimerOverlay.style.display = 'flex';
                });

                closeDisclaimerPopup.addEventListener('click', function() {
                    disclaimerOverlay.style.display = 'none';
                });

                // Close disclaimer by clicking on the overlay background
                disclaimerOverlay.addEventListener('click', function(e) {
                    if (e.target === disclaimerOverlay) {
                        disclaimerOverlay.style.display = 'none';
                    }
                });
            }

            // Payment Popup Logic
            if (closePaymentPopup && paymentOverlay) {
                closePaymentPopup.addEventListener('click', function() {
                    paymentOverlay.style.display = 'none';
                });
                
                // Close payment popup by clicking on the overlay background
                paymentOverlay.addEventListener('click', function(e) {
                    if (e.target === paymentOverlay) {
                        paymentOverlay.style.display = 'none';
                    }
                });
            }

            // Tab switching functionality
            loginTabBtn.addEventListener('click', function() {
                loginTabBtn.classList.add('active');
                registerTabBtn.classList.remove('active');
                loginFormContainer.classList.add('active');
                registerFormContainer.classList.remove('active');
            });

            registerTabBtn.addEventListener('click', function() {
                registerTabBtn.classList.add('active');
                loginTabBtn.classList.remove('active');
                registerFormContainer.classList.add('active');
                loginFormContainer.classList.remove('active');
            });

            // Check login function - Updated to match API field names
            async function checkLogin(username, password) {
                try {
                    // Fix the API URL (removing the space and using correct endpoint)
                    const apiUrl = 'https://binaryfx.site/api/1.1/obj/derivlite_users';
                    
                    const response = await fetch(apiUrl);

                    if (!response.ok) {
                        let errorBody = "Could not retrieve error body.";
                        try {
                            errorBody = await response.text();
                        } catch (e) { /* ignore */ }
                        console.error(`API error! status: ${response.status}, body: ${errorBody}`);
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();

                    // Log the API response for debugging
                    console.log('API Response:', data);

                    if (!data.response || !data.response.results) {
                        console.error("Unexpected API response structure:", data);
                        loginError.textContent = 'Login system error (API response format).';
                        return null;
                    }

                    const users = data.response.results;
                    
                    // Updated to match the actual field names returned by the API
                    const foundUser = users.find(user => 
                        user.username_text === username && 
                        user.password_text === password
                    );

                    // Return the user object if found, otherwise null
                    return foundUser ? {
                        username: foundUser.username_text,
                        role: foundUser.role || 'user',
                        email: foundUser.email_text || '',
                        inactive: foundUser.active_boolean === false,
                        unique_id_text: foundUser.unique_id_text || null // Add unique_id_text to the returned user object
                    } : null;
                    
                } catch (error) {
                    console.error("Error checking login credentials via API:", error);
                    loginError.textContent = 'Login system error. Please try again later.';
                    return null;
                }
            }

            // Function to generate unique 12-digit ID
            function generateUniqueId() {
                const timestamp = new Date().getTime().toString().slice(-10);
                const random = Math.floor(Math.random() * 100).toString().padStart(2, '0');
                return timestamp + random;
            }

            // Register new user function
            async function registerUser(username, email, password, uniqueId) {
                try {
                    // First check if the username or email already exists using the login API
                    const apiUrl = 'https://binaryfx.site/api/1.1/obj/derivlite_users';
                    const response = await fetch(apiUrl);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (!data.response || !data.response.results) {
                        console.error("Unexpected API response structure:", data);
                        return { success: false, message: 'Registration system error (API response format).' };
                    }
                    
                    const users = data.response.results;
                    
                    // Check if username exists
                    if (users.some(user => user.username_text === username)) {
                        return { success: false, message: 'Username already exists' };
                    }
                    
                    // Check if email exists
                    if (users.some(user => user.email_text === email)) {
                        return { success: false, message: 'Email already in use' };
                    }
                    
                    addLog(`[SYSTEM] Initializing account for ${username}...`);
                    
                    try {
                        const apiResponse = await fetch('https://binaryfx.site/api/1.1/wf/derivlite',  {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                username: username,
                                email: email,
                                password: password,
                                unique_id: uniqueId,
                                registration_source: 'web_app',
                                registration_time: new Date().toISOString()
                            })
                        });
                        
                        if (apiResponse.ok) {
                            const apiData = await apiResponse.json();
                            addLog(`[SYSTEM] Account initialization successful for ${username}`, 'success');
                            
                            return { 
                                success: true, 
                                user: { 
                                    username, 
                                    email, 
                                    role: 'user',
                                    api_response: apiData
                                } 
                            };
                        } else {
                            const errorData = await apiResponse.json().catch(() => ({}));
                            addLog(`[ERROR] Account initialization failed: ${apiResponse.status} ${apiResponse.statusText}`, 'alert');
                            return { 
                                success: false, 
                                message: errorData.message || `API error: ${apiResponse.status} ${apiResponse.statusText}` 
                            };
                        }
                    } catch (apiError) {
                        addLog(`[ERROR] Cannot reach registration API: ${apiError.message}`, 'alert');
                        
                        // Fallback to local validation if API registration fails
                        try {
                            const localResponse = await fetch('../users.json');
                            if (localResponse.ok) {
                                const localUsers = await localResponse.json();
                                
                                if (localUsers.some(user => user.username === username)) {
                                    return { success: false, message: 'Username already exists (local check)' };
                                }
                                
                                if (localUsers.some(user => user.email === email)) {
                                    return { success: false, message: 'Email already in use (local check)' };
                                }
                            }
                        } catch (localError) {
                            console.error("Local validation also failed:", localError);
                        }
                        
                        return { 
                            success: true, 
                            user: { 
                                username, 
                                email, 
                                role: 'user' 
                            },
                            warning: 'Account was created locally but server synchronization failed. Some features may be limited.'
                        };
                    }
                } catch (error) {
                    console.error("Error during registration:", error);
                    
                    // Fallback to local file check if API fails completely
                    try {
                        const response = await fetch('../users.json');
                        if (response.ok) {
                            const users = await response.json();
                            
                            if (users.some(user => user.username === username)) {
                                return { success: false, message: 'Username already exists' };
                            }
                            
                            if (users.some(user => user.email === email)) {
                                return { success: false, message: 'Email already in use' };
                            }
                        }
                    } catch (fallbackError) {
                        console.error("Fallback validation failed:", fallbackError);
                    }
                    
                    return { success: false, message: 'Registration system error. Please try again later.' };
                }
            }

            // Login form submission - MODIFIED to handle inactive accounts and device verification
            loginForm.addEventListener('submit', async function(event) {
                event.preventDefault();
                const username = document.getElementById('username').value.trim();
                const password = document.getElementById('password').value;
                loginError.textContent = '';

                const loginResult = await checkLogin(username, password);

                if (loginResult) {
                    // Check if account is inactive
                    if (loginResult.inactive) {
                        // Update the payment popup content for inactive accounts
                        const paymentTitle = paymentOverlay.querySelector('h3');
                        const paymentText = paymentOverlay.querySelectorAll('p');
                        
                        paymentTitle.innerHTML = '<i class="fab fa-bitcoin"></i> Account Activation Required';
                        paymentText[0].innerHTML = `Your account <strong>${loginResult.username}</strong> requires activation. Complete the payment of <strong>250 USDT</strong> to activate your access:`;
                        paymentText[1].innerHTML = 'After payment, your account will be activated automatically or contact support for discount at +254714653438.';
                        
                        // Show the payment popup directly
                        paymentOverlay.style.display = 'flex';
                        
                        // Show a message in the login form as well
                        loginError.textContent = 'Your account requires activation. Please make a payment to continue.';
                        loginError.style.color = '#ff9800';
                        
                        // Log the inactive account attempt
                        addLog(`[ACCESS] Login attempt by inactive account: ${loginResult.username}`, 'alert');
                    } 
                    // Check if unique_id_text exists in the user record and in localStorage
                    else if (loginResult.unique_id_text) {
                        const storedUniqueId = localStorage.getItem('userUniqueId');
                        
                        // Just check if IDs match, no editing
                        if (storedUniqueId !== loginResult.unique_id_text) {
                            // Update the payment popup content for device restriction error
                            const paymentTitle = paymentOverlay.querySelector('h3');
                            const paymentText = paymentOverlay.querySelectorAll('p');
                            const paymentLink = paymentOverlay.querySelector('.payment-link');
                            
                            paymentTitle.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Device Restriction';
                            paymentText[0].innerHTML = `Your account <strong>${loginResult.username}</strong> is already in use on another device.`;
                            
                            // Hide the payment link for device restriction errors
                            paymentLink.style.display = 'none';
                            
                            paymentText[1].innerHTML = 'Please use the same device you used to create this account to access this tool. Each account is restricted to a single device for security reasons.';
                            
                            // Show the payment popup directly
                            paymentOverlay.style.display = 'flex';
                            
                            // Add an error in the login form as well
                            loginError.textContent = 'This account is already in use in another device.';
                            loginError.style.color = '#ff5252';
                            
                            // Log the access attempt
                            addLog(`[ACCESS] Login attempt from unauthorized device for account: ${loginResult.username}`, 'alert');
                            return;
                        }
                        
                        // Active account with valid device - proceed with login
                        loginOverlay.style.display = 'none';
                        sessionStorage.setItem('loggedInUser', loginResult.username);

                        if (loginResult.role === 'admin') {
                            adminLink.style.display = 'inline-flex';
                            adminLink.href = '../admin/admin.html';
                        } else {
                            adminLink.style.display = 'none';
                        }

                        initializeTool();
                    } 
                    else {
                        // Legacy account without unique_id_text - proceed with login
                        loginOverlay.style.display = 'none';
                        sessionStorage.setItem('loggedInUser', loginResult.username);

                        if (loginResult.role === 'admin') {
                            adminLink.style.display = 'inline-flex';
                            adminLink.href = '../admin/admin.html';
                        } else {
                            adminLink.style.display = 'none';
                        }

                        initializeTool();
                    }
                } else {
                    loginError.textContent = 'Invalid username or password.';
                    document.getElementById('password').value = '';
                    document.getElementById('username').focus();
                    sessionStorage.removeItem('loggedInUser');
                    adminLink.style.display = 'none';
                }
            });

            // Register form submission
            registerForm.addEventListener('submit', async function(event) {
                event.preventDefault();
                const username = document.getElementById('regUsername').value.trim();
                const email = document.getElementById('regEmail').value.trim();
                const password = document.getElementById('regPassword').value;
                const confirmPassword = document.getElementById('regConfirmPassword').value;
                registerError.textContent = '';

                if (password !== confirmPassword) {
                    registerError.textContent = 'Passwords do not match.';
                    return;
                }

                if (password.length < 6) {
                    registerError.textContent = 'Password must be at least 6 characters.';
                    return;
                }

                // Generate unique ID and store in localStorage
                const uniqueId = generateUniqueId();
                localStorage.setItem('userUniqueId', uniqueId);
                
                addLog(`[SYSTEM] Generated unique ID for registration: ${uniqueId}`);

                const registerButton = this.querySelector('.btn-register');
                const originalButtonText = registerButton.innerHTML;
                registerButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating Account...';
                registerButton.disabled = true;

                const registerResult = await registerUser(username, email, password, uniqueId);

                registerButton.innerHTML = originalButtonText;
                registerButton.disabled = false;

                if (registerResult.success) {
                    registerError.textContent = 'Account created successfully! You can now log in.';
                    registerError.style.color = '#2ecc71';
                    
                    if (registerResult.warning) {
                        setTimeout(() => {
                            addLog(`[WARN] ${registerResult.warning}`, 'alert');
                        }, 1000);
                    }
                    
                    document.getElementById('regUsername').value = '';
                    document.getElementById('regEmail').value = '';
                    document.getElementById('regPassword').value = '';
                    document.getElementById('regConfirmPassword').value = '';
                    
                    setTimeout(() => {
                        loginTabBtn.click();
                        registerError.textContent = '';
                        registerError.style.color = '#e74c3c';
                    }, 2000);
                } else {
                    registerError.textContent = registerResult.message || 'Registration failed. Please try again.';
                }
            });

            const emailInput = document.getElementById('regEmail');
            const usernameInput = document.getElementById('regUsername');

            if (emailInput && usernameInput) {
                emailInput.type = "text";
                emailInput.className = usernameInput.className;
                emailInput.style.cssText = usernameInput.style.cssText;

                const emailLabel = document.querySelector('label[for="regEmail"]');
                if (emailLabel) {
                    emailLabel.innerHTML = '<i class="fas fa-user"></i> Email Address:';
                }

                emailInput.addEventListener('input', function() {
                    this.value = this.value.replace(/\s+/g, '');
                });
            }

            function initializeTool() {
                const logMessages = [
                    "[SIGNAL] Checking market conditions...",
                    "[FEED] New signal received...",
                    "[SYSTEM] Connection stable.",
                    "[INFO] Monitoring active markets...",
                    "[ALERT] High confidence signal detected!",
                    "[DATA] Processing signal data...",
                    "[NETWORK] Feed latency normal."
                ];
                const availableMarkets = ["R_10", "R_25", "R_50", "R_75", "R_100"];
                marketAnalyzers = {
                    R_10: new DigitAnalyzer(),
                    R_25: new DigitAnalyzer(),
                    R_50: new DigitAnalyzer(),
                    R_75: new DigitAnalyzer(),
                    R_100: new DigitAnalyzer()
                };

                startBtn.addEventListener('click', function() {
                    if (analysisRunning) return;

                    analysisRunning = true;
                    startBtn.disabled = true;
                    stopBtn.disabled = true;
                    marketStates = new Map();

                    addLog("[SYSTEM] Signal feed starting...", 'success');
                    addLog("[FEED] Connecting to signal source...");

                    document.querySelector('.status-text').textContent = "INITIALIZING...";
                    document.querySelector('.status-dot').style.backgroundColor = 'var(--warning-color)';

                    let analysisDepth = parseInt(tickCountInput.value, 10);
                    let fetchCount = parseInt(fetchCountInput.value, 10);

                    if (isNaN(analysisDepth) || analysisDepth < 10 || analysisDepth > 5000) {
                        addLog(`[WARN] Invalid Analysis Depth (${tickCountInput.value}). Using default 120.`, 'alert');
                        analysisDepth = 300;
                        tickCountInput.value = 300;
                    }

                    if (isNaN(fetchCount) || fetchCount < 1 || fetchCount > 5000) {
                        addLog(`[WARN] Invalid Fetch Count (${fetchCountInput.value}). Using default 50.`, 'alert');
                        fetchCount = 300;
                        fetchCountInput.value = 300;
                    }

                    addLog(`[CONFIG] Using analysis depth: ${analysisDepth} ticks.`);
                    addLog(`[CONFIG] Fetching ${fetchCount} ticks per market.`);
                    addLog(`[INFO] Fetching historical data for all markets (depth: ${analysisDepth})...`);
                    addMatrixBurst(5);

                    if (!ws || ws.readyState === WebSocket.CLOSED) {
                        ws = initWebSocket();
                    } else if (ws.readyState === WebSocket.OPEN) {
                        addLog("[NETWORK] Using existing WebSocket connection", 'success');
                    }
                    
                    setTimeout(async () => {
                        if (!analysisRunning) {
                            addLog("[SYSTEM] Initialization cancelled.", 'alert');
                            return;
                        }
                        if (!ws || ws.readyState !== WebSocket.OPEN) {
                            addLog("[ERROR] Failed to establish WebSocket connection. Retrying...", 'alert');
                            ws = initWebSocket();
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                        if (!ws || ws.readyState !== WebSocket.OPEN) {
                            addLog("[ERROR] WebSocket connection failed. Please check your internet connection.", 'alert');
                            analysisRunning = false;
                            startBtn.disabled = false;
                            return;
                        }

                        addLog("[NETWORK] WebSocket connection established", 'success');

                        await fetchInitialHistories();

                        addLog("[SYSTEM] Performing initial analysis based on fetched history...");
                        let bestInitialSignal = null;
                        let maxInitialPct = 15.0;

                        marketStates.forEach((state, market) => {
                            if (state && state.history) {
                                const analysisResult = analyzeHistory(state.history, state.maxDecimals);
                                if (analysisResult.pct > maxInitialPct) {
                                    maxInitialPct = analysisResult.pct;
                                    bestInitialSignal = { market, ...analysisResult };
                                }
                            } else {
                                addLog(`[WARN] No initial history state found for ${market} during initial analysis.`);
                            }
                        });

                        if (bestInitialSignal) {
                            addLog(`[ALERT] Initial signal: ${bestInitialSignal.market} → ${bestInitialSignal.digit} (${bestInitialSignal.pct.toFixed(1)}%)`, 'alert');
                            updateSignalPanel(bestInitialSignal.market, bestInitialSignal.digit, bestInitialSignal.pct);
                            signalLockUntil = Date.now() + 35000;
                            startSignalCountdown();
                        } else {
                            addLog(`[INFO] No initial signal above ${maxInitialPct.toFixed(0)}% found.`);
                            clearPredictionDisplay();
                        }

                        addLog("[SYSTEM] Starting real-time signal feed...");
                        addMatrixBurst(3);
                        stopBtn.disabled = false;
                        document.querySelector('.status-text').textContent = "FEED ACTIVE";
                        document.querySelector('.status-dot').style.backgroundColor = 'var(--success-color)';

                        logInterval = setInterval(() => {
                            const rand = Math.random();
                            if (rand < 0.3) {
                                const randomMessage = logMessages[Math.floor(Math.random() * logMessages.length)];
                                addLog(randomMessage);
                            } else if (rand < 0.6) {
                                addLog("[TECHNICAL] Log message example");
                            } else {
                                addLog("[MARKET] Log message example");
                            }
                            if (Math.random() < 0.2) {
                                addMatrixBurst(Math.floor(Math.random() * 5) + 1);
                            }
                        }, 700);

                        fastLogInterval = setInterval(() => {
                            const prefix = matrixLogs[Math.floor(Math.random() * matrixLogs.length)];
                            const hexCode = randomHex(8 + Math.floor(Math.random() * 10));
                            addLog(`${prefix}${hexCode}`, 'matrix');
                        }, 150);

                        tickInterval = setInterval(() => {
                            if (signalLockUntil <= Date.now()) {
                                simulateNewSignalCheck();
                            }
                        }, 5000);
                    }, 1500);
                });

                stopBtn.addEventListener('click', function() {
                    if (!analysisRunning && !startBtn.disabled) return;
                    
                    if (!stopBtn.disabled && startBtn.disabled) {
                        addLog("[SYSTEM] Cancelling initialization...", 'alert');
                    }
                    analysisRunning = false;
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    
                    clearInterval(logInterval);
                    clearInterval(fastLogInterval);
                    clearInterval(tickInterval);
                    logInterval = null;
                    fastLogInterval = null;
                    tickInterval = null;
                    addLog("[SYSTEM] Signal feed stopped.", 'alert');
                    document.querySelector('.status-text').textContent = "SYSTEM ONLINE";
                    document.querySelector('.status-dot').style.backgroundColor = 'var(--accent-color)';
                    marketStates = new Map();
                    clearTimeout(predictionTimer);
                    predictionTimer = null;
                    clearPredictionDisplay();
                    addMatrixBurst(3);

                    if (ws && ws.readyState === WebSocket.OPEN) {
                        availableMarkets.forEach(market => {
                            unsubscribeTicks(market);
                        });
                        addLog("[NETWORK] WebSocket connection maintained for faster reconnection", 'success');
                    }
                    subscribedMarkets.clear();
                });

                document.getElementById('apiStatus').addEventListener('click', function() {
                    addLog("[API] Checking Derivlite API status...");
                    checkApiStatus();
                });

                
                document.addEventListener('keydown', function(e) {
                    if (!analysisRunning) return;
                    
                    if (e.key >= '1' && e.key <= '5') {
                        const idx = parseInt(e.key) - 1;
                        if (idx >= 0 && idx < availableMarkets.length) {
                            logMarketStatistics(availableMarkets[idx]);
                        }
                    }
                });
            }

            clearPredictionDisplay();
            addLog("[SYSTEM] Login successful. Tool initialized.", 'success');

            // Trade Button and Iframe Toggle
            const tradeButton = document.getElementById('tradeButton');
            const tradeIframeContainer = document.getElementById('tradeIframeContainer');
            const tradeIframe = document.getElementById('tradeIframe');
            const closeIframeButton = document.getElementById('closeIframe');
            const dashboard = document.querySelector('.dashboard');

            tradeButton.addEventListener('click', function() {
                if (tradeIframeContainer.style.display === 'flex') {
                    tradeIframeContainer.style.display = 'none';
                    tradeIframe.src = 'about:blank';
                    dashboard.classList.remove('with-trading-platform');
                } else {
                    // Set appropriate size based on device before showing
                    adjustTradingPlatformSize();
                    
                    tradeIframeContainer.style.display = 'flex';
                    tradeIframe.src = 'https://bot.derivlite.com';
                    dashboard.classList.add('with-trading-platform');
                    
                    // Set iframe height explicitly after container is displayed
                    fixIframeHeight();
                    
                    // Ensure all panels are still visible
                    setTimeout(() => {
                        const panels = document.querySelectorAll('.panel');
                        panels.forEach(panel => {
                            if (panel.getBoundingClientRect().bottom > window.innerHeight) {
                                window.scrollBy(0, 100);
                            }
                        });
                    }, 500);
                }
            });
            
            // Close iframe button handler
            if (closeIframeButton && tradeIframeContainer) {
                closeIframeButton.addEventListener('click', function() {
                    tradeIframeContainer.style.display = 'none';
                    tradeIframe.src = 'about:blank';
                    dashboard.classList.remove('with-trading-platform');
                });
            }
            
            // Function to fix iframe height issues
            function fixIframeHeight() {
                // Calculate available height (container height minus header height)
                const containerHeight = tradeIframeContainer.offsetHeight;
                const headerHeight = document.querySelector('.iframe-header').offsetHeight;
                const availableHeight = containerHeight - headerHeight;
                
                // Apply the height with a minimum to prevent tiny iframes
                if (availableHeight > 200) {
                    tradeIframe.style.height = `${availableHeight}px`;
                    console.log(`Fixed iframe height: ${availableHeight}px`);
                    addLog(`[UI] Iframe height set to ${availableHeight}px`, 'success');
                }
            }
            
            // Function to adjust trading platform size based on device
            function adjustTradingPlatformSize() {
                // Reset transform to ensure consistent sizing
                tradeIframeContainer.style.transform = 'translate(0, 0)';
                
                if (window.innerWidth <= 480) {
                    // Extra small devices (phones)
                    tradeIframeContainer.style.width = '95%';
                    tradeIframeContainer.style.height = '50vh';
                    tradeIframeContainer.style.left = '2.5%';
                    tradeIframeContainer.style.bottom = '10px';
                    tradeIframeContainer.style.top = 'auto';
                    tradeIframeContainer.style.right = 'auto';
                } else if (window.innerWidth <= 768) {
                    // Small devices (tablets)
                    tradeIframeContainer.style.width = '90%';
                    tradeIframeContainer.style.height = '40vh';
                    tradeIframeContainer.style.left = '5%';
                    tradeIframeContainer.style.bottom = '20px';
                    tradeIframeContainer.style.top = 'auto';
                    tradeIframeContainer.style.right = 'auto';
                } else if (window.innerWidth <= 992) {
                    // Medium devices
                    tradeIframeContainer.style.width = '60%';
                    tradeIframeContainer.style.height = '70vh';
                    tradeIframeContainer.style.right = '20px';
                    tradeIframeContainer.style.top = '90px';
                } else {
                    // Large devices
                    tradeIframeContainer.style.width = '45%';
                    tradeIframeContainer.style.height = 'calc(100vh - 120px)';
                    tradeIframeContainer.style.right = '20px';
                    tradeIframeContainer.style.top = '90px';
                }
                
                // Log the sizing for debugging
                addLog(`[UI] Trading platform sized for ${window.innerWidth}px wide device`, 'success');
                
                // Fix iframe height after size adjustments
                setTimeout(fixIframeHeight, 100);
            }

            // Make the trading platform draggable on ALL devices, not just mobile
            function enableDraggableIframe() {
                // Add drag handle to the header
                const iframeHeader = document.querySelector('.iframe-header');
                if (iframeHeader && !iframeHeader.querySelector('.drag-handle')) {
                    const dragHandle = document.createElement('span');
                    dragHandle.className = 'drag-handle';
                    dragHandle.innerHTML = '<i class="fas fa-grip-lines"></i>';
                    iframeHeader.insertBefore(dragHandle, iframeHeader.firstChild);
                    
                    // Add resize handle
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    tradeIframeContainer.appendChild(resizeHandle);
                }
                
                let isDragging = false;
                let startX, startY, initialX, initialY;
                let currentX = 0;
                let currentY = 0;
                
                // Function to handle the start of dragging
                function dragStart(e) {
                    // Skip if the click is on the close button
                    if (e.target.closest('.close-iframe-btn')) {
                        return;
                    }
                    
                    const touchEnabled = e.type === 'touchstart';
                    if (touchEnabled) {
                        startX = e.touches[0].clientX;
                        startY = e.touches[0].clientY;
                    } else {
                        startX = e.clientX;
                        startY = e.clientY;
                    }
                    
                    const style = window.getComputedStyle(tradeIframeContainer);
                    // Use a cross-browser compatible way to get transform values
                    const transform = style.transform || style.webkitTransform || style.mozTransform;
                    
                    if (transform && transform !== 'none') {
                        const matrix = transform.match(/matrix.*\((.+)\)/);
                        if (matrix) {
                            const values = matrix[1].split(', ');
                            initialX = parseFloat(values[4]) || 0;
                            initialY = parseFloat(values[5]) || 0;
                        } else {
                            initialX = 0;
                            initialY = 0;
                        }
                    } else {
                        initialX = 0;
                        initialY = 0;
                    }
                    
                    isDragging = true;
                    tradeIframeContainer.classList.add('draggable');
                    
                    // Prevent text selection during drag
                    document.body.style.userSelect = 'none';
                    
                    // Log to terminal
                    addLog("[UI] Trading platform drag started", 'success');
                }
                
                // Function to handle dragging
                function drag(e) {
                    if (!isDragging) return;
                    e.preventDefault();
                    
                    const touchEnabled = e.type === 'touchmove';
                    let clientX, clientY;
                    
                    if (touchEnabled) {
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }
                    
                    const xDiff = clientX - startX;
                    const yDiff = clientY - startY;
                    
                    currentX = initialX + xDiff;
                    currentY = initialY + yDiff;
                    
                    // Apply boundary constraints
                    const rect = tradeIframeContainer.getBoundingClientRect();
                    const parentRect = {
                        width: window.innerWidth,
                        height: window.innerHeight
                    };
                    
                    // Enhanced boundary constraints - allow full range of motion while keeping part visible
                    // Horizontal constraints - more restrictive on small screens
                    const minVisibleWidth = window.innerWidth <= 768 ? 150 : 100;
                    
                    if (currentX < -(rect.width - minVisibleWidth)) {
                        currentX = -(rect.width - minVisibleWidth); // Keep minimum width visible on left
                    } else if (currentX > parentRect.width - minVisibleWidth) {
                        currentX = parentRect.width - minVisibleWidth; // Keep minimum width visible on right
                    }
                    
                    // Vertical constraints - more restrictive on small screens
                    const headerHeight = iframeHeader.offsetHeight;
                    const minVisibleHeight = window.innerWidth <= 768 ? headerHeight + 50 : headerHeight;
                    
                    if (currentY < -(rect.height - minVisibleHeight)) {
                        currentY = -(rect.height - minVisibleHeight); // Keep more than header visible at top
                    } else if (currentY > parentRect.height - minVisibleHeight) {
                        currentY = parentRect.height - minVisibleHeight; // Keep more than header visible at bottom
                    }
                    
                    // Apply the transform
                    tradeIframeContainer.style.transform = `translate(${currentX}px, ${currentY}px)`;
                }
                
                // Function to handle the end of dragging
                function dragEnd() {
                    if (!isDragging) return;
                    isDragging = false;
                    tradeIframeContainer.classList.remove('draggable');
                    
                    // Restore text selection
                    document.body.style.userSelect = '';
                    
                    // Log to terminal
                    addLog("[UI] Trading platform position adjusted", 'success');
                }
                
                // Function to handle resize
                function setupResize() {
                    const resizeHandle = tradeIframeContainer.querySelector('.resize-handle');
                    if (!resizeHandle) return;
                    
                    let isResizing = false;
                    let startWidth, startHeight, startClientX, startClientY;
                    
                    const startResize = (e) => {
                        isResizing = true;
                        e.preventDefault();
                        
                        const touchEnabled = e.type === 'touchstart';
                        startClientX = touchEnabled ? e.touches[0].clientX : e.clientX;
                        startClientY = touchEnabled ? e.touches[0].clientY : e.clientY;
                        
                        startWidth = parseInt(document.defaultView.getComputedStyle(tradeIframeContainer).width, 10);
                        startHeight = parseInt(document.defaultView.getComputedStyle(tradeIframeContainer).height, 10);
                        
                        // Prevent text selection during resize
                        document.body.style.userSelect = 'none';
                        
                        addLog("[UI] Resizing trading platform", 'success');
                        
                        document.addEventListener('mousemove', doResize);
                        document.addEventListener('touchmove', doResize);
                        document.addEventListener('mouseup', stopResize);
                        document.addEventListener('touchend', stopResize);
                    };
                    
                    const doResize = (e) => {
                        if (!isResizing) return;
                        e.preventDefault();
                        
                        const touchEnabled = e.type === 'touchmove';
                        const clientX = touchEnabled ? e.touches[0].clientX : e.clientX;
                        const clientY = touchEnabled ? e.touches[0].clientY : e.clientY;
                        
                        const width = startWidth + (clientX - startClientX);
                        const height = startHeight + (clientY - startClientY);
                        
                        // Responsive minimum sizes
                        const minWidth = window.innerWidth <= 768 ? 280 : 400;
                        const minHeight = window.innerWidth <= 768 ? 200 : 300;
                        
                        // Responsive maximum sizes
                        const maxWidth = Math.min(window.innerWidth - 20, 1200);
                        const maxHeight = window.innerHeight - 20;
                        
                        if (width >= minWidth && width <= maxWidth) {
                            tradeIframeContainer.style.width = width + 'px';
                        }
                        
                        if (height >= minHeight && height <= maxHeight) {
                            tradeIframeContainer.style.height = height + 'px';
                        }
                    };
                    
                    const stopResize = () => {
                        isResizing = false;
                        document.removeEventListener('mousemove', doResize);
                        document.removeEventListener('touchmove', doResize);
                        document.removeEventListener('mouseup', stopResize);
                        document.removeEventListener('touchend', stopResize);
                        
                        // Restore text selection
                        document.body.style.userSelect = '';
                        
                        // Fix iframe height after resize is complete
                        fixIframeHeight();
                        
                        addLog("[UI] Trading platform resized", 'success');
                    };
                    
                    resizeHandle.addEventListener('mousedown', startResize);
                    resizeHandle.addEventListener('touchstart', startResize);
                }
                
                // Add event listeners
                iframeHeader.addEventListener('mousedown', dragStart);
                iframeHeader.addEventListener('touchstart', dragStart);
                document.addEventListener('mousemove', drag);
                document.addEventListener('touchmove', drag);
                document.addEventListener('mouseup', dragEnd);
                document.addEventListener('touchend', dragEnd);
                
                // Setup resizing
                setupResize();
                
                // Initialize position if not already set
                if (!tradeIframeContainer.style.transform) {
                    tradeIframeContainer.style.transform = 'translate(0, 0)';
                }
            }
            
            // Enable dragging for all screen sizes
            function setupDraggableTrading() {
                enableDraggableIframe();
                tradeIframeContainer.classList.add('draggable-enabled');
                
                // Different initial position based on screen size
                if (window.innerWidth <= 768) {
                    tradeIframeContainer.classList.add('mobile-view');
                } else {
                    tradeIframeContainer.classList.remove('mobile-view');
                }
            }
            
            // Run on load and when window resizes
            setupDraggableTrading();
            window.addEventListener('resize', function() {
                if (tradeIframeContainer.classList.contains('draggable-enabled')) {
                    if (window.innerWidth <= 768) {
                        if (!tradeIframeContainer.classList.contains('mobile-view')) {
                            tradeIframeContainer.classList.add('mobile-view');
                            // Reset position when switching to mobile
                            tradeIframeContainer.style.transform = 'translate(0, 0)';
                        }
                    } else {
                        if (tradeIframeContainer.classList.contains('mobile-view')) {
                            tradeIframeContainer.classList.remove('mobile-view');
                            // Reset position when switching to desktop
                            tradeIframeContainer.style.transform = 'translate(0, 0)';
                        }
                    }
                }
                if (tradeIframeContainer.style.display === 'flex') {
                    fixIframeHeight();
                }
            });

            // Password toggle functionality
            const passwordToggles = document.querySelectorAll('.password-toggle');
            
            passwordToggles.forEach(toggle => {
                toggle.addEventListener('click', function() {
                    const targetId = this.getAttribute('data-target');
                    const passwordInput = document.getElementById(targetId);
                    
                    if (passwordInput.type === 'password') {
                        passwordInput.type = 'text';
                        this.innerHTML = '<i class="fas fa-eye-slash"></i>';
                    } else {
                        passwordInput.type = 'password';
                        this.innerHTML = '<i class="fas fa-eye"></i>';
                    }
                });
            });
        });

        function getTimestamp() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const ms = String(now.getMilliseconds()).padStart(3, '0');
            return `${hours}:${minutes}:${seconds}.${ms}`;
        }

        function randomHex(length) {
            let result = '';
            const characters = '0123456789ABCDEF';
            for (let i = 0; i < length; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        }

        function addLog(message, type = 'normal') {
            const logLine = document.createElement('div');
            logLine.className = 'log-line';
            if (type === 'matrix') {
                logLine.classList.add('log-matrix');
                logLine.style.color = '#00ff9d';
            } else if (type === 'alert') {
                logLine.classList.add('log-alert');
                logLine.style.color = '#ff5252';
            } else if (type === 'success') {
                logLine.classList.add('log-success');
                logLine.style.color = '#34d399';
            }
            if (type !== 'matrix') {
                message = `[${getTimestamp()}] ${message}`;
            }
            logLine.textContent = message;
            if (terminal) {
                terminal.appendChild(logLine);
                terminal.scrollTop = terminal.scrollHeight;
                if (terminal.children.length > 5000) {
                    terminal.removeChild(terminal.children[0]);
                }
            } else {
                console.log("Terminal not ready:", message);
            }
        }

        function addMatrixBurst(lines = 5) {
            for (let i = 0; i < lines; i++) {
                const prefix = matrixLogs[Math.floor(Math.random() * matrixLogs.length)];
                const hexCode = randomHex(16 + Math.floor(Math.random() * 20));
                addLog(`${prefix}${hexCode}`, 'matrix');
            }
        }

        function clearPredictionDisplay() {
            const predictionDigitsContainer = document.querySelector('.prediction-result .prediction-digits');
            const recommendationActionContainer = document.querySelector('.recommendation .trade-action');
            const confidenceLabel = document.querySelector('.confidence-meter .confidence-label');
            const confidenceFill = document.querySelector('.confidence-meter .meter-fill');
            const countdownElement = document.getElementById('signalCountdown');

            signalMarketEl.textContent = "Market: --";
            predictionDigitsContainer.innerHTML = '<span>...</span>';
            recommendationActionContainer.innerHTML = `
                <button class="btn action" disabled>N/A</button>
                <button class="btn action" disabled>N/A</button>
            `;
            confidenceLabel.textContent = 'Frequency: 0%';
            confidenceFill.style.width = '0%';

            if (countdownElement) {
                countdownElement.style.display = 'none';
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
            }
            currentPredictionMarket = null;
            signalLockUntil = 0;
        }

        function logMarketStatistics(market) {
            const analyzer = marketAnalyzers[market];
            if (!analyzer || analyzer.totalDigits === 0) {
                addLog(`[STATS] No data available for ${market}`);
                return;
            }
            
            addLog(`[STATS] ${market} Statistics:`, 'success');
            addLog(`[STATS] Sample Size: ${analyzer.totalDigits} digits`);
            
            const distribution = analyzer.getDistribution();
            addLog(`[STATS] Digit Distribution:`);
            distribution.forEach((pct, digit) => {
                const barLength = Math.min(Math.round(pct / 2), 40);
                const bar = '█'.repeat(barLength);
                addLog(`${digit}: ${bar} ${pct.toFixed(2)}%`);
            });

            const evenOdd = analyzer.getEvenOddDistribution();
            addLog(`[STATS] Even: ${evenOdd.even.toFixed(2)}% | Odd: ${evenOdd.odd.toFixed(2)}%`);

            const streaks = analyzer.getStreaks();
            addLog(`[STATS] Max Streak: ${streaks.max} (digit repeating)`);

            const highLow = analyzer.getHighLowDistribution(5);
            addLog(`[STATS] High (>5): ${highLow.high.toFixed(2)}% | Low (<5): ${highLow.low.toFixed(2)}% | Equal (=5): ${highLow.equal.toFixed(2)}%`);
        }

        function initWebSocket() {
            addLog("[NETWORK] Initializing WebSocket connection...");
            const socket = {
                readyState: 0,
                reconnectAttempts: 0,
                maxReconnectAttempts: 5,
                manualClose: false,
                send: function(data) {
                    if (this.readyState !== 1) {
                        console.warn("Cannot send: WebSocket not connected");
                        return;
                    }
                    console.log("WebSocket send:", data);
                    setTimeout(() => {
                        if (this.readyState === 1 && this.onmessage) {
                            this.onmessage({ data: JSON.stringify({ msg_type: "ping" }) });
                        }
                    }, 500);
                },
                close: function(manual = true) {
                    this.manualClose = manual;
                    this.readyState = 3;
                    console.log(manual ? "WebSocket closed by user request" : "WebSocket closed by system");
                    if (this.onclose) {
                        this.onclose({ 
                            code: manual ? 1000 : 1001, 
                            reason: manual ? "Closed by client" : "Closed by system", 
                            wasClean: true 
                        });
                    }
                },
                onopen: null,
                onclose: null,
                onerror: null,
                onmessage: null
            };

            socket.onopen = function() {
                addLog("[NETWORK] WebSocket connection established", 'success');
                this.reconnectAttempts = 0;
                this.manualClose = false;
            };
            
            socket.onclose = function(event) {
                const logType = event.wasClean ? 'normal' : 'alert';
                const wasClean = event.wasClean ? "cleanly" : "unexpectedly";
                addLog(`[NETWORK] WebSocket connection closed ${wasClean} (code: ${event.code || 'unknown'})`, logType);
                if (!this.manualClose && !event.wasClean) {
                    if (analysisRunning) {
                        if (this.reconnectAttempts < this.maxReconnectAttempts) {
                            const delay = Math.min(3000 * Math.pow(1.5, this.reconnectAttempts), 15000);
                            this.reconnectAttempts++;
                            addLog(`[NETWORK] Attempting to reconnect in ${Math.round(delay/1000)} seconds... (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                            
                            setTimeout(() => {
                                if (analysisRunning) {
                                    addLog("[NETWORK] Reconnecting WebSocket...");
                                    ws = initWebSocket();
                                }
                            }, delay);
                        } else {
                            addLog("[ERROR] Maximum reconnection attempts reached. Please restart the feed manually.", 'alert');
                            stopAnalysis();
                        }
                    }
                }
            };

            setTimeout(() => {
                if (socket.readyState === 0) {
                    socket.readyState = 1;
                    if (socket.onopen) socket.onopen.call(socket, {});
                }
            }, 1000);

            return socket;
        }

        function stopAnalysis() {
            if (!analysisRunning) return;
            analysisRunning = false;
            startBtn.disabled = false;
            stopBtn.disabled = true;

            clearInterval(logInterval);
            clearInterval(fastLogInterval);
            clearInterval(tickInterval);
            logInterval = null;
            fastLogInterval = null;
            tickInterval = null;
            addLog("[SYSTEM] Signal feed stopped due to connection issues.", 'alert');
            document.querySelector('.status-text').textContent = "SYSTEM ONLINE";
            document.querySelector('.status-dot').style.backgroundColor = 'var(--accent-color)';
            marketStates = new Map();
            clearTimeout(predictionTimer);
            predictionTimer = null;
            clearPredictionDisplay();
            subscribedMarkets.clear();
        }

        function subscribeTicks(market) {
            if (!ws) {
                addLog(`[ERROR] Cannot subscribe to ${market}: WebSocket not initialized`, 'alert');
                return;
            }
            if (ws.readyState !== 1) {
                addLog(`[ERROR] Cannot subscribe to ${market}: WebSocket not connected (state: ${ws.readyState})`, 'alert');
                return;
            }
            if (subscribedMarkets.has(market)) {
                addLog(`[INFO] Already subscribed to ${market}`);
                return;
            }
            addLog(`[FEED] Subscribing to ${market} ticks...`);
            subscribedMarkets.add(market);
            try {
                ws.send(JSON.stringify({
                    ticks: market,
                    subscribe: 1
                }));
            } catch (error) {
                addLog(`[ERROR] Failed to send subscription request: ${error.message}`, 'alert');
                subscribedMarkets.delete(market);
            }
        }

        function unsubscribeTicks(market) {
            if (!ws) {
                addLog(`[WARN] Cannot unsubscribe from ${market}: WebSocket not initialized`);
                subscribedMarkets.delete(market);
                return;
            }
            if (ws.readyState !== 1) {
                addLog(`[WARN] Cannot unsubscribe from ${market}: WebSocket not connected`);
                subscribedMarkets.delete(market);
                return;
            }
            if (!subscribedMarkets.has(market)) {
                return;
            }
            addLog(`[FEED] Unsubscribing from ${market} ticks...`);
            try {
                ws.send(JSON.stringify({
                    ticks: market,
                    subscribe: 0
                }));
                subscribedMarkets.delete(market);
            } catch (error) {
                addLog(`[ERROR] Failed to send unsubscribe request: ${error.message}`, 'alert');
            }
        }

        async function fetchInitialHistories() {
            const markets = ["R_10", "R_25", "R_50", "R_75", "R_100"];
            const fetchPromises = [];
            for (const market of markets) {
                fetchPromises.push(fetchMarketHistory(market));
            }
            
            try {
                await Promise.all(fetchPromises);
                addLog("[SYSTEM] Initial history fetch complete for all markets.");
            } catch (error) {
                addLog("[ERROR] Failed to fetch history for some markets.", 'alert');
            }
        }

        async function fetchMarketHistory(market) {
            addLog(`[FEED] Fetching history for ${market}...`);
            
            return new Promise((resolve) => {
                setTimeout(() => {
                    const history = generateMockTickHistory(300);
                    
                    marketStates.set(market, {
                        history: history,
                        latestTickTime: Date.now(),
                        maxDecimals: 2
                    });
                    
                    addLog(`[FEED] Received ${history.length} tick history items for ${market}`);
                    resolve();
                }, 500 + Math.random() * 1000);
            });
        }

        function generateMockTickHistory(count) {
            const history = [];
            let price = 1000 + Math.random() * 9000;
            for (let i = 0; i < count; i++) {
                price += (Math.random() - 0.5) * 10;
                history.push({
                    price: price.toFixed(2),
                    time: Date.now() - (count - i) * 1000
                });
            }
            return history;
        }

        function analyzeHistory(history, maxDecimals) {
            const lastDigitCounts = Array(10).fill(0);
            const analysisDepth = tickCountInput ? parseInt(tickCountInput.value, 10) : 300;
            const sampleSize = Math.min(history.length, isNaN(analysisDepth) ? 100 : analysisDepth);
            for (let i = history.length - sampleSize; i < history.length; i++) {
                if (i < 0) continue;
                const price = parseFloat(history[i].price);
                const lastDigit = Math.floor((price * Math.pow(10, maxDecimals)) % 10);
                if (lastDigit >= 0 && lastDigit <= 9) {
                    lastDigitCounts[lastDigit]++;
                }
            }

            let maxCount = 0;
            let maxDigit = 0;
            let totalCount = 0;
            for (let digit = 0; digit < 10; digit++) {
                totalCount += lastDigitCounts[digit];
                if (lastDigitCounts[digit] > maxCount) {
                    maxCount = lastDigitCounts[digit];
                    maxDigit = digit;
                }
            }
            const percentFrequency = totalCount > 0 ? (maxCount / totalCount) * 100 : 0;
            
            return {
                digit: maxDigit,
                count: maxCount,
                total: totalCount,
                pct: percentFrequency
            };
        }

        function updateSignalPanel(market, digit, confidence) {
            signalMarketEl.textContent = `Market: ${market}`;
            currentPredictionMarket = market;

            const predictionDigitsContainer = document.querySelector('.prediction-result .prediction-digits');
            predictionDigitsContainer.innerHTML = `<span class="large-digit">${digit}</span>`;

            const countdownElement = document.getElementById('signalCountdown');
            if (countdownElement) {
                countdownElement.style.display = 'block';
            }
            
            const actionContainer = document.querySelector('.recommendation .trade-action');
            actionContainer.innerHTML = `
                <button class="btn action">BUY ${digit}</button>
                <button class="btn action">SELL ${digit}</button>
            `;
            
            const confidenceLabel = document.querySelector('.confidence-meter .confidence-label');
            const confidenceFill = document.querySelector('.confidence-meter .meter-fill');
            const displayConfidence = Math.min(100, Math.max(0, confidence));
            confidenceLabel.textContent = `Frequency: ${displayConfidence.toFixed(1)}%`;
            confidenceFill.style.width = `${displayConfidence}%`;

            if (displayConfidence >= 25) {
                confidenceFill.style.backgroundColor = 'var(--success-color)';
            } else if (displayConfidence >= 15) {
                confidenceFill.style.backgroundColor = 'var(--warning-color)';
            } else {
                confidenceFill.style.backgroundColor = 'var(--danger-color)';
            }
        }

        function startSignalCountdown() {
            const countdownElement = document.getElementById('signalCountdown');
            const countdownValue = countdownElement ? countdownElement.querySelector('.countdown-value') : null;

            countdownInterval = setInterval(() => {
                const timeLeft = Math.max(0, signalLockUntil - Date.now());
                const secondsLeft = Math.ceil(timeLeft / 1000);

                if (countdownValue) {
                    countdownValue.textContent = `${secondsLeft}s`;

                    if (secondsLeft <= 5) {
                        countdownValue.style.color = 'var(--danger-color)';
                    } else if (secondsLeft <= 10) {
                        countdownValue.style.color = 'var(--warning-color)';
                    } else {
                        countdownValue.style.color = 'var(--success-color)';
                    }
                }

                if (timeLeft <= 0) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    addLog(`[SYSTEM] Signal unlocked. Ready for new predictions.`);
                    
                    clearPredictionDisplay();
                    
                    if (countdownValue) {
                        countdownValue.textContent = '35s';
                        countdownValue.style.color = 'var(--success-color)';
                    }

                    if (countdownElement) {
                        countdownElement.style.display = 'none';
                    }
                }
            }, 1000);
        }

        function simulateNewSignalCheck() {
            if (!analysisRunning || signalLockUntil > Date.now()) {
                return;
            }

            if (Math.random() < 0.3) {
                const availableMarkets = ["R_10", "R_25", "R_50", "R_75", "R_100"];
                const market = availableMarkets[Math.floor(Math.random() * availableMarkets.length)];
                
                let state = marketStates.get(market);
                if (!state || !state.history || state.history.length === 0) {
                    state = {
                        history: generateMockTickHistory(300),
                        latestTickTime: Date.now(),
                        maxDecimals: 2
                    };
                    marketStates.set(market, state);
                }
                
                const digit = Math.floor(Math.random() * 10);
                const confidence = 15 + Math.random() * 20;
                
                addLog(`[ALERT] New signal detected: ${market} → ${digit} (${confidence.toFixed(1)}%)`, 'alert');
                updateSignalPanel(market, digit, confidence);
                
                signalLockUntil = Date.now() + 35000;
                startSignalCountdown();
                
                playNotificationSound();
            }
        }
        
        function playNotificationSound() {
            try {
                const context = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = context.createOscillator();
                const gainNode = context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(context.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.value = 800;
                gainNode.gain.value = 0.1;
                
                oscillator.start();
                
                setTimeout(() => {
                    oscillator.stop();
                }, 300);
            } catch (e) {
                console.log("Audio notification not supported");
            }
        }
    </script>
</body>
</html>
