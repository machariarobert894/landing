<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIGIT//MATCH - Market Signal Tool</title>
    <link rel="stylesheet" href="../css/tools.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- PWA Manifest Link -->
    <link rel="manifest" href="manifest.json">
    <!-- Theme Color for PWA -->
    <meta name="theme-color" content="#2c3e50">
</head>
<body>
    <!-- Login Modal -->
    <div id="loginOverlay" class="login-overlay">
        <div class="login-popup">
            <h2><i class="fas fa-lock"></i> Secure Access</h2>
            <form id="loginForm">
                <div class="input-group">
                    <label for="username"><i class="fas fa-user"></i> Username:</label>
                    <input type="text" id="username" name="username" required>
                </div>
                <div class="input-group">
                    <label for="password"><i class="fas fa-key"></i> Password:</label>
                    <input type="password" id="password" name="password" required>
                </div>
                <button type="submit" class="btn primary btn-login"><i class="fas fa-sign-in-alt"></i> Login</button>
                <div id="loginError" class="login-error"></div>
            </form>
            <a href="#" id="getLoginLink" class="get-login-link">Need an account? Get Login Credentials</a>
        </div>
    </div>

    <!-- Payment Modal -->
    <div id="paymentOverlay" class="payment-overlay">
        <div class="payment-popup">
            <button id="closePaymentPopup" class="close-btn">&times;</button>
            <h3><i class="fab fa-bitcoin"></i> Payment Request</h3>
            <p>Derivlite has requested <strong>250 USDT</strong> payment. Tap the link below to complete the payment via Binance:</p>
            <a href="https://s.binance.com/R29up4mZ" target="_blank" class="payment-link">
                https://s.binance.com/R29up4mZ
            </a>
            <p>After payment, contact support to receive your login credentials.</p>
        </div>
    </div>

    <div class="container">
        <header class="main-header">
            <div class="logo">DIGIT<span class="accent">//</span>MATCH</div>
            <!-- Admin Panel Link Placeholder -->
            <a href="#" id="adminLink" class="admin-link"><i class="fas fa-user-shield"></i> Admin Panel</a>
            <div class="status-indicator">
                <span class="status-dot"></span>
                <span class="status-text">SYSTEM ONLINE</span>
            </div>
        </header>

        <div class="dashboard">
            <div class="panel control-panel">
                <h2><i class="fas fa-power-off"></i> System Control</h2>
                <div class="control-group">
                    <button id="startAnalysis" class="btn primary"><i class="fas fa-play"></i> START FEED</button>
                    <button id="stopAnalysis" class="btn danger" disabled><i class="fas fa-stop"></i> STOP FEED</button>
                </div>
                <div class="settings">
                    <div class="setting-group">
                        <label for="tickCount">Analysis Depth:</label>
                        <input type="number" id="tickCount" value="300" min="10" max="5000">
                    </div>
                    <!-- Add new setting for fetch count -->
                    <div class="setting-group">
                        <label for="fetchCount">Fetch Count:</label>
                        <input type="number" id="fetchCount" value="300" min="1" max="5000">
                    </div>
                    <!-- Add a checkbox to enable dynamic tick fetching -->
                    <div class="setting-group">
                        <label for="dynamicFetch">Dynamic Fetch:</label>
                        <input type="checkbox" id="dynamicFetch" checked>
                    </div>
                </div>
            </div>

            <div class="panel log-terminal">
                <h2><i class="fas fa-terminal"></i> Signal Log</h2>
                <div class="terminal" id="terminal">
                    <div class="log-line">[SYSTEM] Signal tool initialized...</div>
                    <div class="log-line">[INFO] Click "START FEED" to begin receiving signals...</div>
                </div>
            </div>

            <div class="panel prediction-panel">
                <h2><i class="fas fa-broadcast-tower"></i> Market Signal</h2>
                <div class="prediction-result">
                    <h3 id="signalMarket">Market: --</h3>
                    <div class="prediction-digits">
                        <span>Waiting for signal...</span>
                    </div>
                </div>
                <div class="recommendation">
                    <h3>Trade Recommendation:</h3>
                    <div class="trade-action">
                        <button class="btn action" disabled>N/A</button>
                        <button class="btn action" disabled>N/A</button>
                    </div>
                    <div class="confidence-meter">
                        <div class="confidence-label">Frequency: 0%</div>
                        <div class="meter-bar">
                            <div class="meter-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="../js/tools.js"></script>
    <script>
        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Use absolute path from the domain root
                navigator.serviceWorker.register('/tools/sw.js') 
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Login Modal Elements
            const loginOverlay = document.getElementById('loginOverlay');
            const loginForm = document.getElementById('loginForm');
            const usernameInput = document.getElementById('username');
            const passwordInput = document.getElementById('password');
            const loginError = document.getElementById('loginError');
            const getLoginLink = document.getElementById('getLoginLink'); // Get the new link
            const adminLink = document.getElementById('adminLink'); // Get admin link element

            // Payment Modal Elements
            const paymentOverlay = document.getElementById('paymentOverlay');
            const closePaymentPopup = document.getElementById('closePaymentPopup');

            // --- Existing Tool Elements ---
            const terminal = document.getElementById('terminal');
            const startBtn = document.getElementById('startAnalysis');
            const stopBtn = document.getElementById('stopAnalysis');
            const signalMarketEl = document.getElementById('signalMarket');
            const tickCountInput = document.getElementById('tickCount');
            const fetchCountInput = document.getElementById('fetchCount');
            const dynamicFetchCheckbox = document.getElementById('dynamicFetch');
            let analysisRunning = false;
            let logInterval;
            let fastLogInterval;
            let tickInterval;
            let predictionTimer = null;
            let marketStates = new Map(); // Stores { history: [], latestTickTime: 0, maxDecimals: 0 }
            let subscribedMarkets = new Set(); // Add subscription tracking
            let signalLockUntil = 0; // Timestamp when next signal can be shown
            let countdownInterval = null;
            let currentPredictionMarket = null; // Track which market has an active prediction
            let ws = null;

            // --- Login Logic ---
            // Modify checkLogin to return the user object or null
            async function checkLogin(username, password) {
                try {
                    const response = await fetch('../users.json');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const users = await response.json();
                    // Find the user that matches username and password
                    const foundUser = users.find(user => user.username === username && user.password === password);
                    return foundUser || null; // Return user object or null
                } catch (error) {
                    console.error("Error checking login credentials:", error);
                    loginError.textContent = 'Login system error. Please try again later.';
                    return null; // Return null on error
                }
            }

            loginForm.addEventListener('submit', async function(event) {
                event.preventDefault();
                const username = usernameInput.value.trim();
                const password = passwordInput.value;
                loginError.textContent = '';

                // Get the user object from checkLogin
                const loggedInUserObject = await checkLogin(username, password);

                if (loggedInUserObject) { // Check if a user object was returned
                    loginOverlay.style.display = 'none';

                    // Store username in sessionStorage
                    sessionStorage.setItem('loggedInUser', loggedInUserObject.username);

                    // Check the role property of the returned user object
                    if (loggedInUserObject.role === 'admin') {
                        adminLink.style.display = 'inline-flex'; // Show the link
                        adminLink.href = '../admin/admin.html'; // Set the correct path
                    } else {
                        adminLink.style.display = 'none'; // Hide for non-admins
                    }

                    initializeTool();
                } else {
                    loginError.textContent = 'Invalid username or password.';
                    passwordInput.value = '';
                    usernameInput.focus();
                    sessionStorage.removeItem('loggedInUser');
                    adminLink.style.display = 'none'; // Ensure link is hidden on failed login
                }
            });

            // --- Payment Popup Logic ---
            getLoginLink.addEventListener('click', function(event) {
                event.preventDefault(); // Prevent default link behavior
                paymentOverlay.style.display = 'flex'; // Show payment popup
            });

            closePaymentPopup.addEventListener('click', function() {
                paymentOverlay.style.display = 'none'; // Hide payment popup
            });

            // Close payment popup if user clicks outside the content area
            paymentOverlay.addEventListener('click', function(event) {
                if (event.target === paymentOverlay) {
                    paymentOverlay.style.display = 'none';
                }
            });

            // --- Tool Initialization Function ---
            // Encapsulate the existing tool setup logic
            function initializeTool() {
                // --- Existing Tool Logic ---
                const logMessages = [
                    "[SIGNAL] Checking market conditions...",
                    "[FEED] New signal received...",
                    "[SYSTEM] Connection stable.",
                    "[INFO] Monitoring active markets...",
                    "[ALERT] High confidence signal detected!",
                    "[DATA] Processing signal data...",
                    "[NETWORK] Feed latency normal."
                ];
                const matrixLogs = [
                    "0x", "HASH:", "ADDR:", "MEM:", "BUFF:", "KEY:", "SEED:"
                ];
                const availableMarkets = ["R_10", "R_25", "R_50", "R_75", "R_100"];

                const marketAnalyzers = {
                    R_10: new DigitAnalyzer(),
                    R_25: new DigitAnalyzer(),
                    R_50: new DigitAnalyzer(),
                    R_75: new DigitAnalyzer(),
                    R_100: new DigitAnalyzer()
                };

                // --- Existing Event Listeners (move inside initializeTool) ---
                startBtn.addEventListener('click', function() {
                    if (analysisRunning) return;

                    analysisRunning = true;
                    startBtn.disabled = true;
                    stopBtn.disabled = true;
                    marketStates = new Map();

                    addLog("[SYSTEM] Signal feed starting...", 'success');
                    addLog("[FEED] Connecting to signal source...");

                    document.querySelector('.status-text').textContent = "INITIALIZING...";
                    document.querySelector('.status-dot').style.backgroundColor = 'var(--warning-color)';

                    let analysisDepth = parseInt(tickCountInput.value, 10);
                    let fetchCount = parseInt(fetchCountInput.value, 10);

                    if (isNaN(analysisDepth) || analysisDepth < 10 || analysisDepth > 5000) {
                        addLog(`[WARN] Invalid Analysis Depth (${tickCountInput.value}). Using default 120.`, 'alert');
                        analysisDepth = 300;
                        tickCountInput.value = 300;
                    }

                    if (isNaN(fetchCount) || fetchCount < 1 || fetchCount > 5000) {
                        addLog(`[WARN] Invalid Fetch Count (${fetchCountInput.value}). Using default 50.`, 'alert');
                        fetchCount = 300;
                        fetchCountInput.value = 300;
                    }

                    addLog(`[CONFIG] Using analysis depth: ${analysisDepth} ticks.`);
                    addLog(`[CONFIG] Fetching ${fetchCount} ticks per market.`);
                    addLog(`[INFO] Fetching historical data for all markets (depth: ${analysisDepth})...`);
                    addMatrixBurst(5);

                    // Initialize WebSocket connection
                    ws = initWebSocket();
                    
                    // Wait for WebSocket to connect before proceeding
                    setTimeout(async () => {
                        if (!analysisRunning) {
                            addLog("[SYSTEM] Initialization cancelled.", 'alert');
                            return;
                        }
                        
                        if (!ws || ws.readyState !== WebSocket.OPEN) {
                            addLog("[ERROR] Failed to establish WebSocket connection. Retrying...", 'alert');
                            ws = initWebSocket(); // Try again
                            await new Promise(resolve => setTimeout(resolve, 1000)); // Wait another second
                        }
                        
                        if (!ws || ws.readyState !== WebSocket.OPEN) {
                            addLog("[ERROR] WebSocket connection failed. Please check your internet connection.", 'alert');
                            analysisRunning = false;
                            startBtn.disabled = false;
                            return;
                        }
                        
                        // Proceed with fetching data now that WebSocket is ready
                        // Wait for histories to be fetched and processed before initial analysis
                        await fetchInitialHistories(); // Make sure this completes
                        
                        addLog("[SYSTEM] Performing initial analysis based on fetched history...");
                        let bestInitialSignal = null;
                        let maxInitialPct = 15.0;

                        // Perform initial analysis after data is fetched and processed
                        marketStates.forEach((state, market) => {
                            // Ensure state and history exist before analyzing
                            if (state && state.history) {
                                const analysisResult = analyzeHistory(state.history, state.maxDecimals);
                                if (analysisResult.pct > maxInitialPct) {
                                    maxInitialPct = analysisResult.pct;
                                    bestInitialSignal = { market, ...analysisResult };
                                }
                            } else {
                                addLog(`[WARN] No initial history state found for ${market} during initial analysis.`);
                            }
                        });

                        if (bestInitialSignal) {
                            addLog(`[ALERT] Initial signal: ${bestInitialSignal.market} → ${bestInitialSignal.digit} (${bestInitialSignal.pct.toFixed(1)}%)`, 'alert');
                            updateSignalPanel(bestInitialSignal.market, bestInitialSignal.digit, bestInitialSignal.pct);
                            signalLockUntil = Date.now() + 15000;
                            startSignalCountdown();
                        } else {
                            addLog(`[INFO] No initial signal above ${maxInitialPct.toFixed(0)}% found.`);
                            clearPredictionDisplay();
                        }

                        addLog("[SYSTEM] Starting real-time signal feed...");
                        addMatrixBurst(3);
                        stopBtn.disabled = false;
                        document.querySelector('.status-text').textContent = "FEED ACTIVE";
                        document.querySelector('.status-dot').style.backgroundColor = 'var(--success-color)';

                        logInterval = setInterval(() => {
                            const rand = Math.random();
                            if (rand < 0.3) {
                                const randomMessage = logMessages[Math.floor(Math.random() * logMessages.length)];
                                addLog(randomMessage);
                            } else if (rand < 0.6) {
                                addLog("[TECHNICAL] Log message example");
                            } else {
                                addLog("[MARKET] Log message example");
                            }
                            if (Math.random() < 0.2) {
                                addMatrixBurst(Math.floor(Math.random() * 5) + 1);
                            }
                        }, 700);

                        fastLogInterval = setInterval(() => {
                            const prefix = matrixLogs[Math.floor(Math.random() * matrixLogs.length)];
                            const hexCode = randomHex(8 + Math.floor(Math.random() * 10));
                            addLog(`${prefix}${hexCode}`, 'matrix');
                        }, 150);
                    }, 1500); // Wait for WebSocket connection
                });

                stopBtn.addEventListener('click', function() {
                    if (!analysisRunning && !startBtn.disabled) return;

                    if (!stopBtn.disabled && startBtn.disabled) {
                        addLog("[SYSTEM] Cancelling initialization...", 'alert');
                    }

                    analysisRunning = false;
                    startBtn.disabled = false;
                    stopBtn.disabled = true;

                    clearInterval(logInterval);
                    clearInterval(fastLogInterval);
                    clearInterval(tickInterval);
                    logInterval = null;
                    fastLogInterval = null;
                    tickInterval = null;

                    addLog("[SYSTEM] Signal feed stopped.", 'alert');
                    document.querySelector('.status-text').textContent = "SYSTEM ONLINE";
                    document.querySelector('.status-dot').style.backgroundColor = 'var(--accent-color)';

                    marketStates = new Map();

                    clearTimeout(predictionTimer);
                    predictionTimer = null;
                    clearPredictionDisplay();
                    addMatrixBurst(3);

                    // Clear subscription tracking
                    subscribedMarkets.clear();

                    // Unsubscribe from all markets
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        availableMarkets.forEach(market => {
                            unsubscribeTicks(market);
                        });
                        
                        // Close the WebSocket connection
                        ws.close();
                        ws = null;
                    }
                });

                document.addEventListener('keydown', function(e) {
                    if (!analysisRunning) return;
                    
                    // Number keys 1-5 to analyze markets
                    if (e.key >= '1' && e.key <= '5') {
                        const idx = parseInt(e.key) - 1;
                        if (idx >= 0 && idx < availableMarkets.length) {
                            logMarketStatistics(availableMarkets[idx]);
                        }
                    }
                });

                // --- Initial Tool State Setup ---
                clearPredictionDisplay();
                addLog("[SYSTEM] Login successful. Tool initialized.", 'success');
            }

            // --- Initial Page Load ---
            // Don't initialize the tool immediately, wait for login.
            addLog("[SYSTEM] Please log in to access the tool.");
            // Ensure admin link is hidden on initial load
            adminLink.style.display = 'none';
            sessionStorage.removeItem('loggedInUser'); // Clear session on page load

            // --- Existing Tool Functions (keep outside initializeTool if they don't depend on DOM elements initialized later) ---
            function getTimestamp() {
                const now = new Date();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const ms = String(now.getMilliseconds()).padStart(3, '0');
                return `${hours}:${minutes}:${seconds}.${ms}`;
            }

            function randomHex(length) {
                let result = '';
                const characters = '0123456789ABCDEF';
                for (let i = 0; i < length; i++) {
                    result += characters.charAt(Math.floor(Math.random() * characters.length));
                }
                return result;
            }

            function addLog(message, type = 'normal') {
                const logLine = document.createElement('div');
                logLine.className = 'log-line';

                if (type === 'matrix') {
                    logLine.classList.add('log-matrix');
                    logLine.style.color = '#00ff9d';
                } else if (type === 'alert') {
                    logLine.classList.add('log-alert');
                    logLine.style.color = '#ff5252';
                } else if (type === 'success') {
                    logLine.classList.add('log-success');
                    logLine.style.color = '#34d399';
                }

                if (type !== 'matrix') {
                    message = `[${getTimestamp()}] ${message}`;
                }

                logLine.textContent = message;
                terminal.appendChild(logLine);
                terminal.scrollTop = terminal.scrollHeight;

                if (terminal.children.length > 5000) {
                    terminal.removeChild(terminal.children[0]);
                }
            }

            function addMatrixBurst(lines = 5) {
                for (let i = 0; i < lines; i++) {
                    const prefix = matrixLogs[Math.floor(Math.random() * matrixLogs.length)];
                    const hexCode = randomHex(16 + Math.floor(Math.random() * 20));
                    addLog(`${prefix}${hexCode}`, 'matrix');
                }
            }

            function clearPredictionDisplay() {
                const predictionDigitsContainer = document.querySelector('.prediction-result .prediction-digits');
                const recommendationActionContainer = document.querySelector('.recommendation .trade-action');
                const confidenceLabel = document.querySelector('.confidence-meter .confidence-label');
                const confidenceFill = document.querySelector('.confidence-meter .meter-fill');

                signalMarketEl.textContent = "Market: --";
                predictionDigitsContainer.innerHTML = '<span>...</span>';
                recommendationActionContainer.innerHTML = `
                    <button class="btn action" disabled>N/A</button>
                    <button class="btn action" disabled>N/A</button>
                `;
                confidenceLabel.textContent = 'Frequency: 0%';
                confidenceFill.style.width = '0%';

                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
                signalLockUntil = 0;

                currentPredictionMarket = null;
            }

            function logMarketStatistics(market) {
                const analyzer = marketAnalyzers[market];
                if (!analyzer || analyzer.totalDigits === 0) {
                    addLog(`[STATS] No data available for ${market}`);
                    return;
                }
                
                addLog(`[STATS] ${market} Statistics:`, 'success');
                
                addLog(`[STATS] Sample Size: ${analyzer.totalDigits} digits`);
                
                const distribution = analyzer.getDistribution();
                addLog(`[STATS] Digit Distribution:`);
                distribution.forEach((pct, digit) => {
                    const barLength = Math.min(Math.round(pct / 2), 40);
                    const bar = '█'.repeat(barLength);
                    addLog(`${digit}: ${bar} ${pct.toFixed(2)}%`);
                });
                
                const evenOdd = analyzer.getEvenOddDistribution();
                addLog(`[STATS] Even: ${evenOdd.even.toFixed(2)}% | Odd: ${evenOdd.odd.toFixed(2)}%`);
                
                const streaks = analyzer.getStreaks();
                addLog(`[STATS] Max Streak: ${streaks.max} (digit repeating)`);
                
                const highLow = analyzer.getHighLowDistribution(5);
                addLog(`[STATS] High (>5): ${highLow.high.toFixed(2)}% | Low (<5): ${highLow.low.toFixed(2)}% | Equal (=5): ${highLow.equal.toFixed(2)}%`);
            }
        });
    </script>
</body>
</html>
