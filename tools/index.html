<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIGIT//MATCH - Market Signal Tool</title>
    <link rel="stylesheet" href="../css/tools.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- PWA Manifest Link -->
    <link rel="manifest" href="manifest.json">
    <!-- Theme Color for PWA -->
    <meta name="theme-color" content="#2c3e50">
</head>
<body>
    <div class="container">
        <header class="main-header">
            <div class="logo">DIGIT<span class="accent">//</span>MATCH</div>
            <div class="status-indicator">
                <span class="status-dot"></span>
                <span class="status-text">SYSTEM ONLINE</span>
            </div>
        </header>

        <div class="dashboard">
            <div class="panel control-panel">
                <h2><i class="fas fa-power-off"></i> System Control</h2>
                <div class="control-group">
                    <button id="startAnalysis" class="btn primary"><i class="fas fa-play"></i> START FEED</button>
                    <button id="stopAnalysis" class="btn danger" disabled><i class="fas fa-stop"></i> STOP FEED</button>
                </div>
                <div class="settings">
                    <div class="setting-group">
                        <label for="tickCount">Analysis Depth:</label>
                        <input type="number" id="tickCount" value="300" min="10" max="5000">
                    </div>
                    <!-- Add new setting for fetch count -->
                    <div class="setting-group">
                        <label for="fetchCount">Fetch Count:</label>
                        <input type="number" id="fetchCount" value="300" min="1" max="5000">
                    </div>
                    <!-- Add a checkbox to enable dynamic tick fetching -->
                    <div class="setting-group">
                        <label for="dynamicFetch">Dynamic Fetch:</label>
                        <input type="checkbox" id="dynamicFetch" checked>
                    </div>
                </div>
            </div>

            <div class="panel log-terminal">
                <h2><i class="fas fa-terminal"></i> Signal Log</h2>
                <div class="terminal" id="terminal">
                    <div class="log-line">[SYSTEM] Signal tool initialized...</div>
                    <div class="log-line">[INFO] Click "START FEED" to begin receiving signals...</div>
                </div>
            </div>

            <div class="panel prediction-panel">
                <h2><i class="fas fa-broadcast-tower"></i> Market Signal</h2>
                <div class="prediction-result">
                    <h3 id="signalMarket">Market: --</h3>
                    <div class="prediction-digits">
                        <span>Waiting for signal...</span>
                    </div>
                </div>
                <div class="recommendation">
                    <h3>Trade Recommendation:</h3>
                    <div class="trade-action">
                        <button class="btn action" disabled>N/A</button>
                        <button class="btn action" disabled>N/A</button>
                    </div>
                    <div class="confidence-meter">
                        <div class="confidence-label">Frequency: 0%</div>
                        <div class="meter-bar">
                            <div class="meter-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="../js/tools.js"></script>
    <script>
        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Use explicit relative path
                navigator.serviceWorker.register('./sw.js') 
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            const terminal = document.getElementById('terminal');
            const startBtn = document.getElementById('startAnalysis');
            const stopBtn = document.getElementById('stopAnalysis');
            const signalMarketEl = document.getElementById('signalMarket');
            const tickCountInput = document.getElementById('tickCount');
            const fetchCountInput = document.getElementById('fetchCount');
            const dynamicFetchCheckbox = document.getElementById('dynamicFetch');
            let analysisRunning = false;
            let logInterval;
            let fastLogInterval;
            let tickInterval;
            let predictionTimer = null;
            let marketStates = new Map(); // Stores { history: [], latestTickTime: 0, maxDecimals: 0 }
            let subscribedMarkets = new Set(); // Add subscription tracking
            let signalLockUntil = 0; // Timestamp when next signal can be shown
            let countdownInterval = null;
            let currentPredictionMarket = null; // Track which market has an active prediction

            const logMessages = [
                "[SIGNAL] Checking market conditions...",
                "[FEED] New signal received...",
                "[SYSTEM] Connection stable.",
                "[INFO] Monitoring active markets...",
                "[ALERT] High confidence signal detected!",
                "[DATA] Processing signal data...",
                "[NETWORK] Feed latency normal."
            ];

            const matrixLogs = [
                "0x", "HASH:", "ADDR:", "MEM:", "BUFF:", "KEY:", "SEED:"
            ];

            const availableMarkets = ["R_10", "R_25", "R_50", "R_75", "R_100"];

            const marketAnalyzers = {
                R_10: new DigitAnalyzer(),
                R_25: new DigitAnalyzer(),
                R_50: new DigitAnalyzer(),
                R_75: new DigitAnalyzer(),
                R_100: new DigitAnalyzer()
            };

            function getTimestamp() {
                const now = new Date();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const ms = String(now.getMilliseconds()).padStart(3, '0');
                return `${hours}:${minutes}:${seconds}.${ms}`;
            }

            function randomHex(length) {
                let result = '';
                const characters = '0123456789ABCDEF';
                for (let i = 0; i < length; i++) {
                    result += characters.charAt(Math.floor(Math.random() * characters.length));
                }
                return result;
            }

            function addLog(message, type = 'normal') {
                const logLine = document.createElement('div');
                logLine.className = 'log-line';

                if (type === 'matrix') {
                    logLine.classList.add('log-matrix');
                    logLine.style.color = '#00ff9d';
                } else if (type === 'alert') {
                    logLine.classList.add('log-alert');
                    logLine.style.color = '#ff5252';
                } else if (type === 'success') {
                    logLine.classList.add('log-success');
                    logLine.style.color = '#34d399';
                }

                if (type !== 'matrix') {
                    message = `[${getTimestamp()}] ${message}`;
                }

                logLine.textContent = message;
                terminal.appendChild(logLine);
                terminal.scrollTop = terminal.scrollHeight;

                if (terminal.children.length > 5000) {
                    terminal.removeChild(terminal.children[0]);
                }
            }

            function addMatrixBurst(lines = 5) {
                for (let i = 0; i < lines; i++) {
                    const prefix = matrixLogs[Math.floor(Math.random() * matrixLogs.length)];
                    const hexCode = randomHex(16 + Math.floor(Math.random() * 20));
                    addLog(`${prefix}${hexCode}`, 'matrix');
                }
            }

            // Utility: Get the highest number of decimal places in an array of prices
            function getMaxDecimalPlaces(prices) {
                let max = 0;
                prices.forEach(price => {
                    const s = String(price);
                    if (s.includes('.')) {
                        const decimals = s.split('.')[1].length;
                        if (decimals > max) max = decimals;
                    }
                });
                return max;
            }

            // WebSocket connection to Deriv/Binary.com API
            let ws = null;
            const APP_ID = '68848'; // Using the app_id provided by user
            const WS_URL = `wss://ws.binaryws.com/websockets/v3?app_id=${APP_ID}`;
            
            // Initialize WebSocket connection with improved reliability
            function initWebSocket() {
                // Clear subscription tracking when creating a new connection
                subscribedMarkets.clear();

                if (ws) {
                    try {
                        ws.close();
                    } catch (e) {
                        // Ignore errors on close
                    }
                }
                
                addLog("[SOCKET] Establishing WebSocket connection...");
                ws = new WebSocket(WS_URL);
                
                ws.onopen = function() {
                    addLog("[SOCKET] Connection established", 'success');
                    // Request history for each market when connection opens
                    if (analysisRunning) {
                        fetchInitialHistories();
                    }
                };
                
                ws.onclose = function(event) {
                    addLog(`[SOCKET] Connection closed (${event.code})`);
                    // Auto-reconnect after delay if analysis is running
                    if (analysisRunning) {
                        addLog("[SOCKET] Attempting to reconnect in 3 seconds...");
                        setTimeout(initWebSocket, 3000);
                    }
                };
                
                ws.onerror = function(error) {
                    addLog(`[SOCKET] Error: Connection issue`, 'alert');
                };
                
                ws.onmessage = function(msg) {
                    try {
                        const data = JSON.parse(msg.data);
                        
                        // Debug received data for transparency
                        if (data.tick) {
                            const price = data.tick.quote;
                            const lastDigit = String(price).slice(-1);
                            addLog(`[DATA] ${data.tick.symbol}: ${price} (Digit: ${lastDigit})`);
                        }
                        
                        processWebSocketMessage(data);
                    } catch (e) {
                        addLog(`[SOCKET] Error processing message: ${e.message}`, 'alert');
                    }
                };
                
                return ws;
            }

            // Process incoming WebSocket messages with better organization
            function processWebSocketMessage(data) {
                // Handle history responses
                if (data.history && data.echo_req && data.echo_req.ticks_history) {
                    const market = data.echo_req.ticks_history;
                    
                    if (!data.history || !data.history.prices || !data.history.times) {
                        addLog(`[ERROR] Invalid history format for ${market}`, 'alert');
                        return;
                    }
                    
                    // Process historical data
                    processHistoricalData(market, data.history);
                }
                
                // Handle tick updates
                if (data.tick) {
                    const market = data.tick.symbol;
                    const price = parseFloat(data.tick.quote);
                    const time = data.tick.epoch;
                    
                    // Process the new tick
                    processNewTick(market, price, time);
                }
                
                // Handle errors
                if (data.error) {
                    addLog(`[API] Error: ${data.error.message}`, 'alert');
                }
            }

            // Update: Use max decimals for last digit extraction in processHistoricalData
            function processHistoricalData(market, history) {
                if (!availableMarkets.includes(market)) return;
                
                // Store in market state
                if (!marketStates.has(market)) {
                    marketStates.set(market, { history: [], latestTickTime: 0, maxDecimals: 0 });
                }
                
                const historyPrices = history.prices.map(p => parseFloat(p));
                const lastTimestamp = history.times[history.times.length - 1] || 0;
                
                // Determine max decimals for this symbol
                const maxDecimals = getMaxDecimalPlaces(historyPrices);
                
                // Update market state
                const state = marketStates.get(market);
                state.history = historyPrices;
                state.latestTickTime = lastTimestamp;
                state.maxDecimals = maxDecimals; // Store for use in new ticks
                
                // Extract last digits for analysis (always using maxDecimals)
                const lastDigits = historyPrices.map(price => {
                    const priceStr = Number(price).toFixed(maxDecimals);
                    const decimals = priceStr.split('.')[1] || '';
                    // If not enough decimals, pad with zeros
                    const padded = decimals.padEnd(maxDecimals, '0');
                    return parseInt(padded.slice(-1), 10);
                });
                
                // Feed data into the analyzer
                const analyzer = marketAnalyzers[market];
                lastDigits.forEach(digit => {
                    if (digit >= 0 && digit <= 9) {
                        analyzer.addDigit(digit);
                    }
                });
                
                // Log success and some analysis stats
                addLog(`[DATA] Processed ${historyPrices.length} historical ticks for ${market}`, 'success');
                
                // Show detailed distribution in log with digit labels
                const distribution = analyzer.getDistribution();
                let distLog = `[DIGITS] ${market}: `;
                distribution.forEach((pct, digit) => {
                    distLog += `${digit}:${pct.toFixed(1)}% `;
                });
                addLog(distLog);
                
                // Show even/odd distribution
                const evenOdd = analyzer.getEvenOddDistribution();
                addLog(`[STATS] ${market}: Even: ${evenOdd.even.toFixed(1)}% | Odd: ${evenOdd.odd.toFixed(1)}%`);
                
                // Update UI with the latest digit
                if (lastDigits.length > 0) {
                    updateDigitDisplay(market, lastDigits[lastDigits.length - 1]);
                }
            }

            // Update the function that displays digit statistics in log
            function processNewTick(market, price, time) {
                if (!availableMarkets.includes(market)) return;
                
                // Get current market state
                if (!marketStates.has(market)) {
                    marketStates.set(market, { history: [], latestTickTime: 0, maxDecimals: 0 });
                }
                
                const state = marketStates.get(market);
                
                // Only process if this is a new tick (avoid duplicates)
                if (time <= state.latestTickTime) {
                    return;
                }
                
                // Use stored maxDecimals for this market, fallback to 2
                const maxDecimals = state.maxDecimals || 2;
                const priceStr = Number(price).toFixed(maxDecimals);
                const decimals = priceStr.split('.')[1] || '';
                const padded = decimals.padEnd(maxDecimals, '0');
                const lastDigit = parseInt(padded.slice(-1), 10);
                
                // Add to state history
                state.history.push(price);
                state.latestTickTime = time;
                
                // Maintain history size
                const analysisDepth = parseInt(tickCountInput.value, 10) || 120;
                if (state.history.length > analysisDepth) {
                    state.history.shift();
                }
                
                // Add to analyzer if valid
                if (lastDigit >= 0 && lastDigit <= 9) {
                    marketAnalyzers[market].addDigit(lastDigit);
                }
                
                // Update UI
                updateDigitDisplay(market, lastDigit);
                
                // Log tick with formatted output
                addLog(`[TICK] ${market}: ${price.toFixed(4)} (Last digit: ${lastDigit})`, 'normal');
                
                // Get the analyzer for this market
                const analyzer = marketAnalyzers[market];
                
                // Every 10 ticks, display full distribution
                if (analyzer.totalDigits % 10 === 0) {
                    // Show digit percentages formatted as bar chart in log
                    const distribution = analyzer.getDistribution();
                    addLog(`[DISTRIBUTION] ${market} digit percentages:`);
                    
                    // Find max percentage for scaling
                    const maxPct = Math.max(...distribution);
                    const scale = 20 / (maxPct || 10); // Max 20 chars wide, prevent divide by 0
                    
                    distribution.forEach((pct, digit) => {
                        const barLength = Math.round(pct * scale);
                        const bar = '█'.repeat(barLength);
                        addLog(`${digit}: ${bar} ${pct.toFixed(1)}%`);
                    });
                    
                    // Use top digit from distribution directly instead of confidence
                    const topDigits = [];
                    for (let i = 0; i < 10; i++) {
                        topDigits.push({ digit: i, pct: distribution[i] });
                    }
                    topDigits.sort((a, b) => b.pct - a.pct);
                    
                    if (topDigits.length > 0) {
                        const bestDigit = topDigits[0];
                        addLog(`[SIGNAL] Highest frequency: Digit ${bestDigit.digit} (${bestDigit.pct.toFixed(1)}%)`, 
                            bestDigit.pct > 15 ? 'alert' : 'normal');
                    }
                }
                
                // Analyze for signal - find markets with confidence > 15%
                analyzeForSignals();
            }

            // Enhanced function to request tick history with dynamic count
            function fetchTicksHistory(market, count = null) {
                // Determine count based on parameters and settings
                if (count === null) {
                    if (dynamicFetchCheckbox.checked) {
                        count = parseInt(fetchCountInput.value, 10) || 300;
                    } else {
                        count = 300; // Default if no dynamic fetching
                    }
                }
                
                // Validate count is within reasonable limits
                count = Math.max(1, Math.min(500, count));
                
                return new Promise((resolve, reject) => {
                    // Add a flag to track if the promise is settled
                    let settled = false;

                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        addLog("[SOCKET] Socket not connected, initializing...");
                        ws = initWebSocket();
                        
                        // Wait for connection to establish
                        setTimeout(() => {
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                sendHistoryRequest();
                            } else {
                                reject(new Error("WebSocket connection failed"));
                            }
                        }, 1000);
                    } else {
                        sendHistoryRequest();
                    }
                    
                    function sendHistoryRequest() {
                        // Create a unique ID for this request to match response
                        const reqId = Math.floor(Date.now() + Math.random() * 1000);
                        
                        // One-time message handler for this specific request
                        function messageHandler(event) {
                            if (settled) return; // Ignore if already settled
                            try {
                                const data = JSON.parse(event.data);
                                
                                // Check if this is the response to our request
                                if (data.req_id === reqId) {
                                    settled = true; // Mark as settled
                                    // Remove this listener as we've got our response
                                    ws.removeEventListener('message', messageHandler);
                                    
                                    if (data.error) {
                                        reject(new Error(data.error.message || "Unknown API error"));
                                        return;
                                    }
                                    
                                    resolve(data);
                                }
                            } catch (e) {
                                // Ignore parsing errors or messages not for us
                            }
                        }
                        
                        // Add temporary listener for this request
                        ws.addEventListener('message', messageHandler);
                        
                        // Create and send request
                        const request = {
                            ticks_history: market,
                            adjust_start_time: 1,
                            count: count,
                            end: "latest",
                            style: "ticks",
                            req_id: reqId
                        };
                        
                        addLog(`[API] Requesting ${count} ticks for ${market}...`);
                        
                        try {
                            ws.send(JSON.stringify(request));
                            
                            // Set timeout for this specific request
                            setTimeout(() => {
                                if (settled) return; // Ignore if already settled
                                settled = true; // Mark as settled
                                ws.removeEventListener('message', messageHandler);
                                reject(new Error("Request timed out"));
                            }, 10000);
                        } catch (error) {
                            if (settled) return; // Ignore if already settled
                            settled = true; // Mark as settled
                            ws.removeEventListener('message', messageHandler);
                            reject(error);
                        }
                    }
                }).catch(error => {
                    addLog(`[ERROR] Fetch failed for ${market}: ${error.message}`, 'alert');
                    throw error; // Re-throw to allow Promise.all to catch it
                });
            }

            // Fetch history for all markets, using fetchCountInput for number of ticks
            function fetchInitialHistories() {
                const fetchCount = parseInt(fetchCountInput.value, 10) || 300;
                addLog(`[CONFIG] Fetching previous ${fetchCount} ticks per market.`);

                const fetchPromises = availableMarkets.map(market =>
                    fetchTicksHistory(market, fetchCount)
                        .then(data => {
                            addLog(`[DATA] Initial history stored for ${market}.`);
                        })
                        .catch(error => {
                            addLog(`[ERROR] Failed to fetch initial history for ${market}: ${error.message}`, 'alert');
                        })
                );

                Promise.all(fetchPromises)
                    .then(() => {
                        addLog(`[DATA] Initial historical data fetched for all markets.`, 'success');
                        availableMarkets.forEach(market => subscribeTicks(market));
                    })
                    .catch(() => {
                        addLog(`[ERROR] Problem during initial data fetch cycle.`, 'alert');
                    });
            }

            // Modified subscribe function to prevent duplicate subscriptions
            function subscribeTicks(market) {
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    addLog("[ERROR] Cannot subscribe, socket not connected", 'alert');
                    return;
                }
                
                // Check if already subscribed to avoid errors
                if (subscribedMarkets.has(market)) {
                    addLog(`[INFO] Already subscribed to ${market}`, 'normal');
                    return;
                }
                
                const request = {
                    ticks: market,
                    subscribe: 1
                };
                
                ws.send(JSON.stringify(request));
                subscribedMarkets.add(market); // Mark as subscribed
                addLog(`[SOCKET] Subscribed to ${market} ticks`);
            }

            // Modified unsubscribe function to update subscription status
            function unsubscribeTicks(market) {
                if (!ws || ws.readyState !== WebSocket.OPEN) return;
                
                if (!subscribedMarkets.has(market)) {
                    return; // Not subscribed, nothing to do
                }
                
                const request = {
                    ticks: market,
                    subscribe: 0
                };
                
                ws.send(JSON.stringify(request));
                subscribedMarkets.delete(market); // Remove from subscribed set
                addLog(`[SOCKET] Unsubscribed from ${market} ticks`);
            }

            // Modify analyzeForSignals to re-analyze current history window each time
            function analyzeForSignals() {
                if (!analysisRunning) return;

                // Check if we're in a signal lock period
                const now = Date.now();
                if (now < signalLockUntil) {
                    return;
                }

                let bestSignal = null;
                let maxPct = 15.0;  // threshold in % to consider

                // Analyze the current history window for each market
                availableMarkets.forEach(market => {
                    const state = marketStates.get(market);
                    // Ensure we have state, history, and enough data
                    if (!state || !state.history || state.history.length < 20) {
                        return;
                    }

                    // Analyze the current history using the market's maxDecimals
                    const analysisResult = analyzeHistory(state.history, state.maxDecimals);

                    // Check if this market has a better signal based on recent history
                    if (analysisResult.pct > maxPct) {
                        maxPct = analysisResult.pct;
                        bestSignal = { market, digit: analysisResult.digit, pct: analysisResult.pct };
                    }
                });

                if (bestSignal) {
                    // Only show signals with meaningful deviations
                    addLog(`[SIGNAL] Recent Trend: ${bestSignal.market}: Digit ${bestSignal.digit} (${bestSignal.pct.toFixed(1)}%)`, 'alert');
                    updateSignalPanel(bestSignal.market, bestSignal.digit, bestSignal.pct);

                    // Lock signal for 15 seconds
                    signalLockUntil = now + 15000;
                    startSignalCountdown();
                }
            }

            // Update analyzeHistory to accept maxDecimals for accurate digit extraction
            function analyzeHistory(history, maxDecimals) {
                if (!history || history.length < 20) {
                    return { market: null, digit: null, pct: 0 };
                }
                 // Use provided maxDecimals, fallback to 2 if undefined/zero
                const effectiveMaxDecimals = maxDecimals > 0 ? maxDecimals : 2;

                const digitCounts = Array(10).fill(0);
                let totalDigits = 0;

                // Count the last digits using the correct decimal places
                history.forEach(price => {
                    const priceStr = Number(price).toFixed(effectiveMaxDecimals);
                    const decimals = priceStr.split('.')[1] || '';
                    // If not enough decimals, pad with zeros
                    const padded = decimals.padEnd(effectiveMaxDecimals, '0');
                    const lastDigit = parseInt(padded.slice(-1), 10);

                    if (!isNaN(lastDigit) && lastDigit >= 0 && lastDigit <= 9) {
                        digitCounts[lastDigit]++;
                        totalDigits++;
                    }
                });

                if (totalDigits < 20) {
                    return { market: null, digit: null, pct: 0 };
                }

                // Find digit with highest percentage in distribution
                let highestPct = 0;
                let bestDigit = -1;

                digitCounts.forEach((count, digit) => {
                    const pct = (count / totalDigits) * 100;
                    if (pct > highestPct) {
                        highestPct = pct;
                        bestDigit = digit;
                    }
                });

                // Return only digit and percentage, market context is handled by caller
                return { digit: bestDigit, pct: highestPct };
            }

            // Add a new function to start signal countdown
            function startSignalCountdown() {
                // Clear any existing countdown
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                }

                const predictionDigitsContainer = document.querySelector('.prediction-result .prediction-digits');
                const countdownEl = document.createElement('div');
                countdownEl.className = 'signal-countdown';
                countdownEl.style.fontSize = '12px';
                countdownEl.style.marginTop = '5px';
                countdownEl.style.color = 'var(--warning-color)';
                
                predictionDigitsContainer.appendChild(countdownEl);

                let secondsLeft = 15;
                updateCountdown();

                // Update countdown every second
                countdownInterval = setInterval(() => {
                    secondsLeft--;
                    updateCountdown();
                    
                    if (secondsLeft <= 0) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                        countdownEl.remove();
                    }
                }, 1000);

                function updateCountdown() {
                    countdownEl.textContent = `Next signal in ${secondsLeft}s`;
                }
            }

            // Update the updateSignalPanel function to track the current prediction market
            function updateSignalPanel(market, digit, percentage) {
                // Save the current prediction market
                currentPredictionMarket = market;
                
                signalMarketEl.textContent = `Market: ${market}`;
                const container = document.querySelector('.prediction-digits');
                
                if (percentage <= 15) {
                    container.innerHTML = '<span>ANALYSING...</span>';
                    return;
                }
                
                // Show only the main prediction with clearer styling
                container.innerHTML = `
                    <div class="prediction-digit high">
                        <span class="pred-number">${digit}</span>
                        <span class="pred-percent">${percentage.toFixed(1)}%</span>
                    </div>
                `;
                
                // Update confidence meter
                document.querySelector('.confidence-label').textContent = `Frequency: ${percentage.toFixed(1)}%`;
                document.querySelector('.meter-fill').style.width = `${percentage}%`;
            }

            async function fetchTicks(market, count = 10) {
                return fetchTicksHistory(market, count);
            }

            // Modify updateDigitDisplay to respect current prediction
            function updateDigitDisplay(market, digit) {
                // Only update if we don't have an active prediction or this is the prediction market
                if (!currentPredictionMarket || market === currentPredictionMarket) {
                    signalMarketEl.textContent = `Market: ${market}`;
                }
                // Don't update the digit display - that's handled by updateSignalPanel
            }

            function clearPredictionDisplay() {
                const predictionDigitsContainer = document.querySelector('.prediction-result .prediction-digits');
                const recommendationActionContainer = document.querySelector('.recommendation .trade-action');
                const confidenceLabel = document.querySelector('.confidence-meter .confidence-label');
                const confidenceFill = document.querySelector('.confidence-meter .meter-fill');

                signalMarketEl.textContent = "Market: --";
                predictionDigitsContainer.innerHTML = '<span>...</span>';
                recommendationActionContainer.innerHTML = `
                    <button class="btn action" disabled>N/A</button>
                    <button class="btn action" disabled>N/A</button>
                `;
                confidenceLabel.textContent = 'Frequency: 0%';
                confidenceFill.style.width = '0%';

                // Also clear any active countdown
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
                signalLockUntil = 0;

                // Reset current prediction market
                currentPredictionMarket = null;
            }

            // Add function to log market statistics on demand
            function logMarketStatistics(market) {
                const analyzer = marketAnalyzers[market];
                if (!analyzer || analyzer.totalDigits === 0) {
                    addLog(`[STATS] No data available for ${market}`);
                    return;
                }
                
                addLog(`[STATS] ${market} Statistics:`, 'success');
                
                // Show sample size
                addLog(`[STATS] Sample Size: ${analyzer.totalDigits} digits`);
                
                // Show detailed distribution
                const distribution = analyzer.getDistribution();
                addLog(`[STATS] Digit Distribution:`);
                distribution.forEach((pct, digit) => {
                    const barLength = Math.min(Math.round(pct / 2), 40);
                    const bar = '█'.repeat(barLength);
                    addLog(`${digit}: ${bar} ${pct.toFixed(2)}%`);
                });
                
                // Show even/odd distribution
                const evenOdd = analyzer.getEvenOddDistribution();
                addLog(`[STATS] Even: ${evenOdd.even.toFixed(2)}% | Odd: ${evenOdd.odd.toFixed(2)}%`);
                
                // Show streaks
                const streaks = analyzer.getStreaks();
                addLog(`[STATS] Max Streak: ${streaks.max} (digit repeating)`);
                
                // Show high/low distribution with reference digit 5
                const highLow = analyzer.getHighLowDistribution(5);
                addLog(`[STATS] High (>5): ${highLow.high.toFixed(2)}% | Low (<5): ${highLow.low.toFixed(2)}% | Equal (=5): ${highLow.equal.toFixed(2)}%`);
            }
            
            // Add event to analyze a specific market (could be triggered by button or keyboard)
            document.addEventListener('keydown', function(e) {
                if (!analysisRunning) return;
                
                // Number keys 1-5 to analyze markets
                if (e.key >= '1' && e.key <= '5') {
                    const idx = parseInt(e.key) - 1;
                    if (idx >= 0 && idx < availableMarkets.length) {
                        logMarketStatistics(availableMarkets[idx]);
                    }
                }
            });

            // Enhanced start button event listener
            startBtn.addEventListener('click', function() {
                if (analysisRunning) return;

                analysisRunning = true;
                startBtn.disabled = true;
                stopBtn.disabled = true;
                marketStates = new Map();

                addLog("[SYSTEM] Signal feed starting...", 'success');
                addLog("[FEED] Connecting to signal source...");

                document.querySelector('.status-text').textContent = "INITIALIZING...";
                document.querySelector('.status-dot').style.backgroundColor = 'var(--warning-color)';

                let analysisDepth = parseInt(tickCountInput.value, 10);
                let fetchCount = parseInt(fetchCountInput.value, 10);

                if (isNaN(analysisDepth) || analysisDepth < 10 || analysisDepth > 5000) {
                    addLog(`[WARN] Invalid Analysis Depth (${tickCountInput.value}). Using default 120.`, 'alert');
                    analysisDepth = 300;
                    tickCountInput.value = 300;
                }

                if (isNaN(fetchCount) || fetchCount < 1 || fetchCount > 5000) {
                    addLog(`[WARN] Invalid Fetch Count (${fetchCountInput.value}). Using default 50.`, 'alert');
                    fetchCount = 300;
                    fetchCountInput.value = 300;
                }

                addLog(`[CONFIG] Using analysis depth: ${analysisDepth} ticks.`);
                addLog(`[CONFIG] Fetching ${fetchCount} ticks per market.`);
                addLog(`[INFO] Fetching historical data for all markets (depth: ${analysisDepth})...`);
                addMatrixBurst(5);

                // Initialize WebSocket connection
                ws = initWebSocket();
                
                // Wait for WebSocket to connect before proceeding
                setTimeout(async () => {
                    if (!analysisRunning) {
                        addLog("[SYSTEM] Initialization cancelled.", 'alert');
                        return;
                    }
                    
                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        addLog("[ERROR] Failed to establish WebSocket connection. Retrying...", 'alert');
                        ws = initWebSocket(); // Try again
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait another second
                    }
                    
                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        addLog("[ERROR] WebSocket connection failed. Please check your internet connection.", 'alert');
                        analysisRunning = false;
                        startBtn.disabled = false;
                        return;
                    }
                    
                    // Proceed with fetching data now that WebSocket is ready
                    // Wait for histories to be fetched and processed before initial analysis
                    await fetchInitialHistories(); // Make sure this completes
                    
                    addLog("[SYSTEM] Performing initial analysis based on fetched history...");
                    let bestInitialSignal = null;
                    let maxInitialPct = 15.0;

                    // Perform initial analysis after data is fetched and processed
                    marketStates.forEach((state, market) => {
                        // Ensure state and history exist before analyzing
                        if (state && state.history) {
                             // Pass maxDecimals to analyzeHistory
                            const analysisResult = analyzeHistory(state.history, state.maxDecimals);
                            if (analysisResult.pct > maxInitialPct) {
                                maxInitialPct = analysisResult.pct;
                                bestInitialSignal = { market, ...analysisResult };
                            }
                        } else {
                             addLog(`[WARN] No initial history state found for ${market} during initial analysis.`);
                        }
                    });

                    if (bestInitialSignal) {
                        addLog(`[ALERT] Initial signal: ${bestInitialSignal.market} → ${bestInitialSignal.digit} (${bestInitialSignal.pct.toFixed(1)}%)`, 'alert');
                        updateSignalPanel(bestInitialSignal.market, bestInitialSignal.digit, bestInitialSignal.pct);
                         // Start countdown for initial signal too
                        signalLockUntil = Date.now() + 15000;
                        startSignalCountdown();
                    } else {
                        addLog(`[INFO] No initial signal above ${maxInitialPct.toFixed(0)}% found.`);
                        clearPredictionDisplay();
                    }

                    addLog("[SYSTEM] Starting real-time signal feed...");
                    addMatrixBurst(3);
                    stopBtn.disabled = false;
                    document.querySelector('.status-text').textContent = "FEED ACTIVE";
                    document.querySelector('.status-dot').style.backgroundColor = 'var(--success-color)';

                    logInterval = setInterval(() => {
                        const rand = Math.random();
                        if (rand < 0.3) {
                            const randomMessage = logMessages[Math.floor(Math.random() * logMessages.length)];
                            addLog(randomMessage);
                        } else if (rand < 0.6) {
                            addLog("[TECHNICAL] Log message example");
                        } else {
                            addLog("[MARKET] Log message example");
                        }
                        if (Math.random() < 0.2) {
                            addMatrixBurst(Math.floor(Math.random() * 5) + 1);
                        }
                    }, 700);

                    fastLogInterval = setInterval(() => {
                        const prefix = matrixLogs[Math.floor(Math.random() * matrixLogs.length)];
                        const hexCode = randomHex(8 + Math.floor(Math.random() * 10));
                        addLog(`${prefix}${hexCode}`, 'matrix');
                    }, 150);
                }, 1500); // Wait for WebSocket connection
            });

            stopBtn.addEventListener('click', function() {
                if (!analysisRunning && !startBtn.disabled) return;

                if (!stopBtn.disabled && startBtn.disabled) {
                    addLog("[SYSTEM] Cancelling initialization...", 'alert');
                }

                analysisRunning = false;
                startBtn.disabled = false;
                stopBtn.disabled = true;

                clearInterval(logInterval);
                clearInterval(fastLogInterval);
                clearInterval(tickInterval);
                logInterval = null;
                fastLogInterval = null;
                tickInterval = null;

                addLog("[SYSTEM] Signal feed stopped.", 'alert');
                document.querySelector('.status-text').textContent = "SYSTEM ONLINE";
                document.querySelector('.status-dot').style.backgroundColor = 'var(--accent-color)';

                marketStates = new Map();

                clearTimeout(predictionTimer);
                predictionTimer = null;
                clearPredictionDisplay();
                addMatrixBurst(3);

                // Clear subscription tracking
                subscribedMarkets.clear();

                // Unsubscribe from all markets
                if (ws && ws.readyState === WebSocket.OPEN) {
                    availableMarkets.forEach(market => {
                        unsubscribeTicks(market);
                    });
                    
                    // Close the WebSocket connection
                    ws.close();
                    ws = null;
                }
            });

            clearPredictionDisplay();
        });
    </script>
</body>
</html>
